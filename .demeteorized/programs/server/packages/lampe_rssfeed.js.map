{"version":3,"file":"/packages/lampe:rssfeed.js","sources":["lampe:rssfeed/rss.server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,E;AACA,0G;AACA,E;;AAEA,W;AACA,oB;AACA,mC;AACA,qE;AACA,I;AACA,C;;AAEA,6B;;AAEA,sB;;AAEA,6C;AACA,uE;AACA,wC;AACA,4B;AACA,E;;AAEA,W;AACA,4C;AACA,wC;AACA,iF;AACA,K;AACA,0D;AACA,gD;AACA,4E;AACA,K;;AAEA,+C;AACA,yC;AACA,I;AACA,6B;AACA,wC;AACA,mF;AACA,K;AACA,2E;AACA,gD;AACA,8B;AACA,I;AACA,mC;AACA,qC;AACA,mB;AACA,K;;AAEA,sD;AACA,I;AACA,+B;AACA,uC;AACA,I;AACA,uC;AACA,2B;AACA,oB;;AAEA,gD;AACA,mC;AACA,6C;AACA,sC;AACA,qC;AACA,wC;AACA,oB;AACA,sC;AACA,sD;AACA,oF;AACA,+D;AACA,kB;AACA,uC;AACA,gE;AACA,sD;AACA,0E;AACA,e;AACA,oB;AACA,wE;AACA,qE;AACA,a;AACA,W;;AAEA,gB;AACA,4C;AACA,4E;AACA,4B;AACA,W;AACA,0D;AACA,+C;AACA,S;AACA,O;AACA,K;;AAEA,kB;AACA,G;AACA,E;;AAEA,+B;AACA,qD;AACA,sB;;AAEA,8B;AACA,kB;AACA,G;;AAEA,wC;AACA,2C;;AAEA,wB;;AAEA,+E;AACA,iB;AACA,gF;AACA,uB;AACA,c;AACA,W;AACA,G;;AAEA,c;AACA,wB;AACA,Y;AACA,I;;AAEA,gC;AACA,gC;AACA,sC;AACA,+E;AACA,+E;AACA,uC;;AAEA,sB;AACA,gB;AACA,iB;AACA,uB;AACA,iB;AACA,0B;AACA,oB;AACA,gB;AACA,qC;AACA,2D;AACA,O;AACA,M;;AAEA,qB;AACA,gC;AACA,sC;AACA,wC;AACA,Q;AACA,qC;AACA,iD;AACA,O;AACA,M;;AAEA,0D;;AAEA,2D;AACA,kC;AACA,4C;AACA,qB;;;AAGA,sC;;AAEA,6E;AACA,4D;AACA,6B;;AAEA,K;AACA,qB;AACA,O;AACA,0B;AACA,gB;AACA,uB;AACA,c;AACA,mG;AACA,G;AACA,S;AACA,G","sourcesContent":["/*\n* meteor-rssfeed â€” This package publishes data as rss feeds, it takes params and listens on the url \"/rss\"\n*/\n\n// Polyfill\nif(!Array.isArray) {\n  Array.isArray = function (vArg) {\n    return Object.prototype.toString.call(vArg) === '[object Array]';\n  };\n}\n\nvar url = Npm.require('url');\n\nvar feedHandlers = {};\n\nvar nameFollowsConventions = function(name) {\n  // TODO: Expand check to follow URI name specs or test name to follow\n  // Meteor.Collection naming convention\n  return name === '' + name;\n};\n\nRssFeed = {\n  publish: function(name, handlerFunction) {\n    if (!nameFollowsConventions(name)) {\n      throw new Error('RssFeed publish expects valid name to be of type String');\n    }\n    // Check if the handlerFunction is actually a function\n    if (typeof handlerFunction !== 'function') {\n      throw new Error('RssFeed publish expects feed handler as a function');\n    }\n\n    // Add the handler function to feedHandlers\n    feedHandlers[name] = handlerFunction;\n  },\n  unpublish: function(name) {\n    if (!nameFollowsConventions(name)) {\n      throw new Error('RssFeed unpublish expects valid name to be of type String');\n    }\n    // We could do a check to se if the name is allready found, if not then\n    // throw an error, but for now we are silent\n    delete feedHandlers[name];\n  },\n  createTag: function(key, value) {\n    if (typeof key === 'undefined') {\n      return value;\n    }\n\n    return '<' + key + '>' + value + '</' + key + '>';\n  },\n  cdataValue: function(value) {\n    return '<![CDATA[' + value + ']]>';\n  },\n  objectToXML: function(sourceObject) {\n    // The returning string\n    var result = '';\n\n    // We do a one level iteration of the object\n    for (var key in sourceObject) {\n      if (sourceObject.hasOwnProperty(key)) {\n        var value = sourceObject[key];\n        // We create <key>value</key>\n        if (typeof value === 'object') {\n          // If date\n          if (value instanceof Date) {\n            // We extract the date into correct format\n            // If Date we produce the formatted date Mon, 06 Sep 2009 16:20:00 +0000\n            result += this.createTag(key, value.toUTCString());\n          } else {\n            if (Array.isArray(value)) {\n              // If array we repeat the tag n times with values?\n              for (var i = 0; i < value.length; i++) {\n                result += this.createTag(key, this.objectToXML(value[i]));\n              }\n            } else {\n              // If objects we do nothing - one could create nested xml?\n              result += this.createTag(key, this.objectToXML(value));\n            }\n          }\n\n        } else {\n          if (typeof value === 'function') {\n            // Should we execute the function and return the value into tag?\n            value = value();\n          }\n          // But if text then incapsulate in <![CDATA[ ]]>\n          result += this.createTag(key, value);\n        }\n      }\n    }\n\n    return result;\n  }\n};\n\n// Handle the actual connection\nWebApp.connectHandlers.use(function(req, res, next) {\n  rssurl = /^\\/rss/gi;\n\n  if (!rssurl.test(req.url)) {\n    return next();\n  }\n\n  var parsed = url.parse(req.url, true);\n  var folders = parsed.pathname.split('/');\n\n  feedName = folders[2];\n\n  // If feedHandler not found or somehow the feedhandler is not a function then\n  // return a 404\n  if (!feedHandlers[feedName] || typeof feedHandlers[feedName] !== 'function') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  var self = {\n    query: parsed.query,\n    res: res\n  };\n\n  // Helper functions this scope\n  Fiber = Npm.require('fibers');\n  fileHandler = Fiber(function(self) {\n    // We fetch feed data from feedHandler, the handler uses the this.addItem()\n    // function to populate the feed, this way we have better check control and\n    // better error handling + messages\n\n    var feedObject = {\n      channel: {\n        title:'',\n        description:'',\n        link: '',\n        lastBuildDate: '',\n        pubDate: '',\n        ttl: '',\n        generator: 'Meteor RSS Feed',\n        item: [] // title, description, link, guid, pubDate\n      }\n    };\n\n    var feedScope = {\n      cdata: RssFeed.cdataValue,\n      setValue: function(key, value) {\n        feedObject.channel[key] = value;\n      },\n      addItem: function(itemObject) {\n        feedObject.channel.item.push(itemObject);\n      }\n    };\n\n    feedHandlers[feedName].apply(feedScope, [self.query]);\n\n    var feed = '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n';\n    feed += '<rss version=\"2.0\">';\n    feed += RssFeed.objectToXML(feedObject);\n    feed += '</rss>';\n\n\n    var feedBuffer = new Buffer(feed);\n\n    self.res.setHeader('Content-Type', 'application/rss+xml; charset=utf-8');\n    self.res.setHeader('Content-Length', feedBuffer.length);\n    self.res.end(feedBuffer);\n\n  });\n  // Run feed handler\n  try {\n    fileHandler.run(self);\n  } catch(err) {\n    res.writeHead(404);\n    res.end();\n    throw new Error('Error in feed handler function, name ' + feedName + ' Error: ' + err.message);\n  }\n  return;\n});\n"]}