{"version":3,"sources":["vazco:universe-html-purifier/HTMLParser.js","vazco:universe-html-purifier/HTMLPurifier.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,E;AACA,wC;AACA,4G;AACA,2D;;AAEA,yE;AACA,G;;AAEA,2G;AACA,gH;AACA,+B;AACA,yF;;AAEA,sB;AACA,sC;AACA,yC;AACA,yB;AACA,Y;AACA,C;;AAEA,mI;;AAEA,oT;;AAEA,6Q;;AAEA,mD;AACA,+B;AACA,4E;;AAEA,kE;AACA,kI;;AAEA,0C;AACA,sC;;AAEA,wC;AACA,kD;AACA,yB;AACA,iC;AACA,G;;AAEA,sD;AACA,2B;AACA,qD;AACA,oC;AACA,I;AACA,G;;AAEA,2D;AACA,8B;AACA,G;;AAEA,sC;;AAEA,e;AACA,yB;;AAEA,wB;AACA,kB;;AAEA,6C;AACA,6C;AACA,kC;AACA,kC;AACA,iC;;AAEA,gB;AACA,gB;AACA,kB;AACA,wD;AACA,O;AACA,M;;AAEA,uB;AACA,2C;AACA,G;AACA,E;;AAEA,uC;AACA,U;;AAEA,2C;AACA,iB;AACA,W;AACA,G;;AAEA,iD;AACA,M;AACA,kD;AACA,mC;AACA,W;;AAEA,mB;AACA,+C;AACA,kD;AACA,sB;AACA,+B;;AAEA,6C;AACA,sB;AACA,G;AACA,E;;AAEA,iB;AACA,e;AACA,qD;AACA,oD;;AAEA,a;AACA,sC;AACA,gC;;AAEA,uB;AACA,2B;AACA,oD;AACA,wC;AACA,mB;AACA,K;;AAEA,a;AACA,2C;AACA,iC;;AAEA,kB;AACA,8C;AACA,6C;AACA,mB;AACA,K;;AAEA,e;AACA,0C;AACA,mC;;AAEA,kB;AACA,8C;AACA,iD;AACA,mB;AACA,K;AACA,I;;AAEA,iB;AACA,8B;;AAEA,6D;AACA,oD;;AAEA,wB;AACA,2B;AACA,I;;AAEA,U;AACA,4F;AACA,8C;AACA,4C;;AAEA,wB;AACA,2B;;AAEA,c;AACA,M;;AAEA,mC;AACA,G;;AAEA,sB;AACA,gC;AACA,c;AACA,E;;AAEA,+B;AACA,e;AACA,E;;;;;;;;;;;;;;;;;;AC5KA,a;;AAEA,sC;AACA,4B;AACA,mB;AACA,6B;AACA,wB;AACA,a;AACA,uB;AACA,qB;AACA,0B;AACA,gC;AACA,oB;;;AAGA,kE;AACA,wD;AACA,8B;AACA,+C;AACA,qE;AACA,6B;AACA,iD;AACA,wB;AACA,wB;AACA,wB;AACA,yB;AACA,M;AACA,mC;AACA,uB;AACA,iB;AACA,iB;AACA,iB;AACA,M;AACA,sB;AACA,qB;AACA,gB;AACA,gB;AACA,iB;AACA,iB;AACA,M;AACA,uB;AACA,+B;AACA,mD;AACA,oC;AACA,+B;AACA,sC;AACA,0B;AACA,yC;AACA,oC;AACA,S;AACA,sB;AACA,M;;AAEA,oC;AACA,8C;AACA,M;;AAEA,0B;AACA,8B;AACA,8B;AACA,U;AACA,kC;AACA,6B;AACA,U;AACA,+B;AACA,+G;AACA,U;AACA,4B;AACA,2C;AACA,S;AACA,M;;AAEA,gC;AACA,yB;AACA,2B;AACA,6B;AACA,M;;AAEA,sB;AACA,uC;AACA,sC;AACA,gC;AACA,yB;AACA,U;AACA,uC;AACA,uE;AACA,iD;AACA,sD;AACA,iB;AACA,a;AACA,wB;AACA,U;AACA,gC;AACA,2D;AACA,U;AACA,4B;AACA,4C;AACA,4C;AACA,yD;AACA,a;AACA,yB;AACA,U;AACA,+B;AACA,kE;AACA,U;AACA,6B;AACA,0C;AACA,U;AACA,qC;AACA,mE;AACA,U;AACA,sC;AACA,4B;;AAEA,8E;AACA,mF;;AAEA,iF;AACA,mD;AACA,qD;AACA,gF;AACA,0C;AACA,2E;AACA,mG;AACA,6D;AACA,0D;AACA,4E;AACA,uC;AACA,yB;AACA,qB;;AAEA,gE;AACA,iB;AACA,a;AACA,0B;AACA,U;AACA,gC;AACA,4B;AACA,uE;AACA,2C;AACA,a;AACA,0B;AACA,U;AACA,kC;AACA,0B;AACA,uE;AACA,2D;AACA,kD;AACA,iB;AACA,a;AACA,wB;AACA,U;AACA,+B;AACA,0C;;AAEA,4B;AACA,yC;AACA,iF;AACA,oB;AACA,+D;AACA,+G;AACA,+D;AACA,oE;AACA,a;AACA,0B;AACA,U;AACA,4B;AACA,8D;AACA,U;AACA,8B;AACA,sE;AACA,2D;AACA,yC;AACA,6B;AACA,a;;AAEA,wD;AACA,qC;AACA,2E;AACA,sD;AACA,8C;AACA,8B;AACA,qB;AACA,iB;AACA,a;AACA,iC;AACA,S;AACA,M;;AAEA,6B;AACA,qB;AACA,2B;AACA,2B;AACA,yB;AACA,qC;AACA,yC;AACA,iC;AACA,4B;AACA,U;AACA,wE;AACA,+C;AACA,U;AACA,wD;;AAEA,kE;AACA,kD;AACA,wD;;AAEA,gC;AACA,uB;AACA,6B;AACA,wC;;;AAGA,oB;AACA,6C;AACA,iD;AACA,2D;AACA,6D;AACA,6D;AACA,a;AACA,yC;AACA,yB;AACA,a;AACA,gD;AACA,kD;AACA,6D;AACA,a;AACA,S;;AAEA,+C;AACA,qD;AACA,6D;AACA,2C;AACA,yB;;AAEA,6E;AACA,0D;AACA,S;;AAEA,gE;AACA,wE;AACA,4D;AACA,a;AACA,S;AACA,K;;AAEA,6B;AACA,6B;AACA,K;;AAEA,2D;AACA,yF;AACA,mB;AACA,S;AACA,kB;AACA,0D;AACA,2C;AACA,2C;AACA,sB;AACA,a;AACA,S;AACA,Y;AACA,sC;AACA,8C;AACA,8B;AACA,uC;AACA,mB;AACA,+C;AACA,K;;AAEA,yD;AACA,0D;AACA,0D;AACA,4B;AACA,a;AACA,S;AACA,qB;AACA,K;;AAEA,gC;AACA,gD;AACA,K;;AAEA,sC;AACA,gD;AACA,4C;AACA,sC;AACA,4B;AACA,mE;AACA,6B;AACA,a;AACA,S;AACA,qB;AACA,K;;AAEA,sD;AACA,qC;AACA,gC;AACA,yC;AACA,yB;AACA,oB;AACA,K;;AAEA,mD;AACA,0C;AACA,yE;AACA,yB;AACA,0C;AACA,S;AACA,K;;AAEA,mC;AACA,6D;AACA,K;;AAEA,6C;AACA,0D;AACA,K;;AAEA,kD;AACA,4E;AACA,K;;AAEA,iD;AACA,uD;AACA,K;;AAEA,mD;AACA,wD;AACA,wB;AACA,S;AACA,K;;AAEA,qD;AACA,kB;AACA,Y;AACA,0C;AACA,6C;AACA,K;;AAEA,qC;AACA,yB;AACA,iB;AACA,qD;AACA,4B;AACA,oC;AACA,4B;AACA,a;AACA,gC;AACA,0B;AACA,0B;AACA,gC;AACA,gD;AACA,+B;AACA,qB;AACA,0B;AACA,2C;AACA,2B;AACA,6B;AACA,6B;AACA,6B;AACA,iD;AACA,2B;AACA,+B;AACA,+C;AACA,2B;AACA,gC;AACA,mD;AACA,2B;AACA,6B;AACA,6C;AACA,2B;AACA,wB;AACA,+B;AACA,gD;AACA,+B;AACA,qB;AACA,a;AACA,S;AACA,K;;AAEA,+B;AACA,mC;AACA,sB;AACA,gB;AACA,sB;AACA,S;AACA,K;;AAEA,2C;AACA,mE;AACA,K;;AAEA,2B;AACA,mD;AACA,K;;AAEA,0B;AACA,2C;AACA,mB;AACA,S;AACA,oF;AACA,4C;AACA,wB;AACA,oC;AACA,uC;AACA,2B;AACA,6D;AACA,6D;AACA,sE;AACA,yB;AACA,a;AACA,gB;AACA,qH;AACA,uB;AACA,a;AACA,yD;AACA,yD;AACA,kE;AACA,S;AACA,K;;AAEA,kB;AACA,yD;AACA,qB;AACA,4C;AACA,uC;AACA,uB;AACA,a;AACA,kC;AACA,kC;AACA,6B;AACA,wC;AACA,+B;AACA,6B;AACA,oC;AACA,+B;AACA,iB;AACA,mC;AACA,kC;AACA,kC;AACA,mC;AACA,+B;AACA,8B;AACA,mC;AACA,+B;AACA,iB;AACA,a;AACA,8B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,wC;AACA,mC;AACA,wC;AACA,uC;AACA,gC;AACA,4C;AACA,yB;AACA,+B;AACA,qB;AACA,kC;AACA,0B;AACA,yB;AACA,0B;AACA,2H;AACA,wC;AACA,iC;AACA,qB;AACA,4D;AACA,2B;AACA,0B;AACA,wC;AACA,iC;AACA,qB;AACA,0C;AACA,gD;AACA,oC;AACA,qB;AACA,4D;AACA,2B;AACA,yB;AACA,sE;AACA,kE;AACA,qC;AACA,6D;AACA,yB;AACA,qB;AACA,iE;AACA,mE;AACA,+C;AACA,2B;AACA,8B;AACA,yB;AACA,0B;AACA,yB;AACA,yB;AACA,4B;AACA,iE;AACA,mE;AACA,+C;AACA,2B;AACA,6B;AACA,wC;AACA,iC;AACA,qB;AACA,4D;AACA,6C;AACA,2B;AACA,0B;AACA,2B;AACA,iE;AACA,4D;AACA,gC;AACA,2B;AACA,a;AACA,sC;AACA,2C;AACA,iE;AACA,4D;AACA,gC;AACA,2B;AACA,wB;AACA,iE;AACA,mE;AACA,+C;AACA,2B;AACA,iB;AACA,a;AACA,U;;AAEA,gD;AACA,iD;AACA,uB;AACA,a;AACA,qB;AACA,4C;AACA,wC;AACA,sC;AACA,sC;AACA,iC;AACA,0C;AACA,mC;AACA,iC;AACA,sC;AACA,mC;AACA,qB;AACA,uC;AACA,sC;AACA,sC;AACA,qC;AACA,mC;AACA,kC;AACA,qC;AACA,mC;AACA,qB;AACA,iB;AACA,kC;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,4C;AACA,4C;AACA,yC;AACA,oC;AACA,8C;AACA,6B;AACA,qC;AACA,mC;AACA,yB;AACA,gD;AACA,wD;AACA,gC;AACA,mD;AACA,4D;AACA,yB;AACA,+B;AACA,sC;AACA,8B;AACA,8B;AACA,+H;AACA,gD;AACA,wD;AACA,yB;AACA,gD;AACA,gC;AACA,mD;AACA,4D;AACA,yB;AACA,+B;AACA,6B;AACA,gD;AACA,+D;AACA,yB;AACA,iD;AACA,mD;AACA,kD;AACA,+C;AACA,yB;AACA,4C;AACA,kD;AACA,qC;AACA,yB;AACA,+B;AACA,8B;AACA,gD;AACA,+D;AACA,yB;AACA,gD;AACA,gC;AACA,mD;AACA,4D;AACA,yB;AACA,+B;AACA,6B;AACA,6B;AACA,8B;AACA,kC;AACA,6B;AACA,6B;AACA,gC;AACA,0E;AACA,0E;AACA,8D;AACA,sC;AACA,6B;AACA,yB;AACA,uF;AACA,mC;AACA,yB;AACA,qH;AACA,wC;AACA,4B;AACA,sD;AACA,uD;AACA,yD;AACA,+B;;AAEA,iB;AACA,mE;AACA,sE;AACA,sE;AACA,0D;AACA,kC;AACA,yB;AACA,qB;AACA,mF;AACA,+B;AACA,qB;AACA,iH;AACA,oC;AACA,wB;AACA,kD;AACA,mD;AACA,qD;AACA,2B;AACA,iB;AACA,a;AACA,kC;AACA,wC;AACA,4C;AACA,qE;AACA,gC;AACA,iB;AACA,a;AACA,S;AACA,M;;AAEA,mB;AACA,gE;AACA,4C;AACA,8B;AACA,+B;AACA,mD;AACA,kF;AACA,+C;AACA,2B;AACA,gC;AACA,mD;AACA,4D;AACA,mD;AACA,2B;AACA,2B;AACA,sC;AACA,iD;AACA,2B;AACA,6B;AACA,6B;AACA,6B;AACA,mD;AACA,4D;AACA,iD;AACA,2B;AACA,0B;AACA,0B;AACA,0B;AACA,mC;AACA,iD;AACA,2B;AACA,a;AACA,U;;AAEA,gD;AACA,gD;AACA,uB;AACA,a;AACA,4C;AACA,8B;AACA,6B;AACA,kD;AACA,iC;AACA,4B;AACA,+C;AACA,wD;AACA,qB;AACA,2C;AACA,2B;AACA,a;AACA,S;AACA,M;;AAEA,qB;AACA,gE;AACA,4C;AACA,8B;AACA,+B;AACA,2B;AACA,gC;AACA,6B;AACA,0B;AACA,6B;AACA,0B;AACA,6B;AACA,0B;AACA,mC;AACA,mC;AACA,2B;AACA,wB;AACA,uE;AACA,2B;AACA,a;AACA,U;;AAEA,gD;AACA,gD;AACA,uB;AACA,a;AACA,4C;AACA,8B;AACA,+B;AACA,oD;AACA,oD;AACA,gE;AACA,qC;AACA,gC;AACA,mD;AACA,8D;AACA,mE;AACA,qD;AACA,yB;AACA,qB;AACA,2B;AACA,4B;AACA,2B;AACA,gC;AACA,4B;AACA,6B;AACA,0B;AACA,6B;AACA,0B;AACA,6B;AACA,0B;AACA,2B;AACA,6B;AACA,mC;AACA,iC;AACA,2B;AACA,wB;AACA,uD;AACA,2B;AACA,a;AACA,S;AACA,M;;AAEA,yB;AACA,gE;AACA,4C;AACA,8B;AACA,4B;AACA,uE;AACA,2B;AACA,2B;AACA,4D;AACA,gC;AACA,2B;AACA,wB;AACA,oC;AACA,mC;AACA,2B;AACA,a;AACA,U;;AAEA,gD;AACA,gD;AACA,uB;AACA,a;AACA,4C;AACA,8B;AACA,gC;AACA,yD;AACA,oC;AACA,iD;AACA,qB;AACA,2B;AACA,2B;AACA,2B;AACA,wB;AACA,oC;AACA,iC;AACA,2B;AACA,a;AACA,S;AACA,M;;AAEA,uB;AACA,gE;AACA,4C;AACA,8B;AACA,0B;AACA,wD;AACA,4D;AACA,2C;AACA,2B;AACA,0B;AACA,0B;AACA,gC;AACA,iD;AACA,2B;AACA,+B;AACA,2B;AACA,gC;AACA,6B;AACA,6B;AACA,6B;AACA,wG;AACA,4D;AACA,iD;AACA,qD;AACA,qB;AACA,2B;AACA,a;AACA,U;;AAEA,gD;AACA,gD;AACA,uB;AACA,a;AACA,4C;AACA,8B;AACA,6B;AACA,6B;AACA,6B;AACA,kD;AACA,4D;AACA,oC;AACA,iD;AACA,qB;AACA,2B;AACA,6B;AACA,wG;AACA,4D;AACA,iD;AACA,qC;AACA,qB;AACA,2B;AACA,4B;AACA,+B;AACA,2B;AACA,gC;AACA,4B;AACA,0B;AACA,0B;AACA,0B;AACA,2B;AACA,wB;AACA,wD;AACA,2B;AACA,a;AACA,S;AACA,M;;AAEA,iB;AACA,gE;AACA,4C;AACA,8B;AACA,0B;AACA,0B;AACA,uD;AACA,uE;AACA,4C;AACA,+C;AACA,2B;AACA,+B;AACA,2B;AACA,gC;AACA,6B;AACA,6B;AACA,6B;AACA,0B;AACA,8B;AACA,iD;AACA,2B;AACA,wB;AACA,wE;AACA,2B;AACA,a;AACA,U;;AAEA,gD;AACA,gD;AACA,uB;AACA,a;AACA,4C;AACA,8B;AACA,0B;AACA,kD;AACA,2D;AACA,oC;AACA,qD;AACA,qB;AACA,2B;AACA,6B;AACA,8B;;AAEA,2F;AACA,4E;AACA,oD;AACA,2B;AACA,6B;AACA,6B;AACA,6B;AACA,kD;AACA,kC;AACA,qC;AACA,qB;AACA,2B;AACA,4B;AACA,+B;AACA,2B;AACA,gC;AACA,4B;AACA,0B;AACA,0B;AACA,2B;AACA,wB;AACA,wD;AACA,2B;AACA,a;AACA,S;AACA,M;;AAEA,kB;AACA,gE;AACA,4C;AACA,8B;AACA,+B;AACA,2B;AACA,gC;AACA,6B;AACA,0B;AACA,6B;AACA,0B;AACA,6B;AACA,0B;AACA,uE;AACA,yC;AACA,qD;AACA,qB;AACA,2B;AACA,wB;AACA,uE;AACA,2B;AACA,a;AACA,U;;AAEA,gD;AACA,gD;AACA,uB;AACA,a;AACA,4C;AACA,8B;AACA,0B;AACA,0B;AACA,kD;AACA,oD;AACA,8D;AACA,mC;AACA,yB;AACA,iC;AACA,4B;AACA,+C;AACA,wD;;AAEA,+D;AACA,+C;AACA,qB;AACA,2B;AACA,4B;AACA,+B;AACA,2B;AACA,gC;AACA,4B;AACA,2B;AACA,6B;AACA,6B;AACA,6B;AACA,6B;AACA,0B;AACA,kD;AACA,yC;AACA,qC;AACA,qB;AACA,2B;AACA,wB;AACA,uD;AACA,2B;AACA,a;AACA,S;AACA,M;;AAEA,mB;;AAEA,Y;AACA,qB;AACA,iB;AACA,qB;AACA,8B;AACA,wD;AACA,S;AACA,M;;AAEA,E;;;AAGA,4B;AACA,oB;AACA,qB;;AAEA,0B;AACA,W;AACA,O;AACA,iG;AACA,oD;AACA,kB;AACA,+D;AACA,Q;AACA,2E;AACA,iF;AACA,4C;AACA,uE;AACA,wD;AACA,Q;AACA,0B;AACA,O;AACA,sB;AACA,O;AACA,qD;AACA,iD;AACA,gG;AACA,kC;AACA,O;AACA,uC;AACA,2C;AACA,0B;AACA,S;AACA,6B;AACA,mD;AACA,mC;AACA,wC;AACA,qB;AACA,sD;;AAEA,a;AACA,8B;AACA,8C;AACA,0C;AACA,6C;AACA,e;AACA,qB;AACA,wC;AACA,wB;AACA,a;AACA,S;AACA,4C;AACA,M;AACA,O;AACA,8D;AACA,uE;AACA,kE;AACA,8C;AACA,O;AACA,8D;AACA,mB;AACA,iC;AACA,S;AACA,+B;AACA,iC;AACA,S;AACA,kD;AACA,gD;AACA,S;AACA,kD;AACA,M;AACA,O;AACA,wC;AACA,0F;AACA,8B;AACA,sE;AACA,O;AACA,yD;AACA,mC;AACA,4B;AACA,wC;AACA,S;AACA,K;;AAEA,E","file":"/packages/vazco_universe-html-purifier.js","sourcesContent":["/*\n * HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Licensed under the Apache License, Version 2.0 or Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n\n * added support of HTML5 by Krzysztof Różalski <cristo.rabani@gmail.com>\n */\n\n// Regular Expressions for parsing tags and attributes (modified attribute name matcher, to catch xml:lang)\nvar startTag = /^<([\\w-]+\\:?\\w*)((?:\\s+[a-zA-Z_:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n\tendTag = /^<\\/([\\w-]+)[^>]*>/,\n\tattr = /([\\w-]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g;\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\tfor ( var i = 0; i < items.length; i++ )\n\t\tobj[ items[i] ] = true;\n\treturn obj;\n}\n\nvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,keygen,link,meta,menuitem,source,track,param,embed,wbr\");\n\nvar block = makeMap(\"article,aside,address,applet,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,form,footer,frameset,hr,iframe,header,hgroup,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,progress,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video\");\n\nvar inline = makeMap(\"a,abbr,acronym,applet,audio,b,basefont,bdo,big,br,button,cite,code,command,del,details,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,mark,meter,nav,object,q,s,samp,script,select,small,span,strike,strong,sub,summary,sup,textarea,tt,u,time,var\");\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\");\n\n// Attributes that have their values filled in disabled=\"disabled\"\nvar fillAttrs = makeMap(\"checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected\");\n\n// Special Elements (can contain anything)\nvar special = makeMap(\"script,style\");\n\nHTMLParser = function( html, handler ) {\n\tvar index, chars, match, stack = [], last = html;\n\tstack.last = function(){\n\t\treturn this[ this.length - 1 ];\n\t};\n\n\tfunction parseStartTag( tag, tagName, rest, unary ) {\n\t\tif ( block[ tagName ] ) {\n\t\t\twhile ( stack.last() && inline[ stack.last() ] ) {\n\t\t\t\tparseEndTag( \"\", stack.last() );\n\t\t\t}\n\t\t}\n\n\t\tif ( closeSelf[ tagName ] && stack.last() === tagName ) {\n\t\t\tparseEndTag( \"\", tagName );\n\t\t}\n\n\t\tunary = empty[ tagName ] || !!unary;\n\n\t\tif ( !unary )\n\t\t\tstack.push( tagName );\n\n\t\tif ( handler.start ) {\n\t\t\tvar attrs = [];\n\n\t\t\trest.replace(attr, function(match, name) {\n\t\t\t\tvar value = arguments[2] ? arguments[2] :\n\t\t\t\t\targuments[3] ? arguments[3] :\n\t\t\t\t\targuments[4] ? arguments[4] :\n\t\t\t\t\tfillAttrs[name] ? name : \"\";\n\n\t\t\t\tattrs.push({\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tescaped: value.replace(/(^|[^\\\\])\"/g, '$1\\\\\\\"') //\"\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif ( handler.start )\n\t\t\t\thandler.start( tagName, attrs, unary );\n\t\t}\n\t}\n\n\tfunction parseEndTag( tag, tagName ) {\n\t\tvar pos;\n\n\t\t// If no tag name is provided, clean shop\n\t\tif (!tagName) {\n\t\t\tpos = 0;\n\t\t}\n\n\t\t// Find the closest opened tag of the same type\n\t\telse\n\t\t\tfor ( pos = stack.length - 1; pos >= 0; pos-- )\n\t\t\t\tif ( stack[ pos ] === tagName )\n\t\t\t\t\tbreak;\n\n\t\tif ( pos >= 0 ) {\n\t\t\t// Close all the open elements, up the stack\n\t\t\tfor ( var i = stack.length - 1; i >= pos; i-- )\n\t\t\t\tif ( handler.end )\n\t\t\t\t\thandler.end( stack[ i ] );\n\n\t\t\t// Remove the open elements from the stack\n\t\t\tstack.length = pos;\n\t\t}\n\t}\n\n\twhile ( html ) {\n\t\tchars = true;\n\t\t// Make sure we're not in a script or style element\n\t\tif ( !stack.last() || !special[ stack.last() ] ) {\n\n\t\t\t// Comment\n\t\t\tif ( html.indexOf(\"<!--\") === 0 ) {\n\t\t\t\tindex = html.indexOf(\"-->\");\n\n\t\t\t\tif ( index >= 0 ) {\n\t\t\t\t\tif ( handler.comment )\n\t\t\t\t\t\thandler.comment( html.substring( 4, index ) );\n\t\t\t\t\thtml = html.substring( index + 3 );\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t// end tag\n\t\t\t} else if ( html.indexOf(\"</\") === 0 ) {\n\t\t\t\tmatch = html.match( endTag );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\thtml = html.substring( match[0].length );\n\t\t\t\t\tmatch[0].replace( endTag, parseEndTag );\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t// start tag\n\t\t\t} else if ( html.indexOf(\"<\") === 0 ) {\n\t\t\t\tmatch = html.match( startTag );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\thtml = html.substring( match[0].length );\n\t\t\t\t\tmatch[0].replace( startTag, parseStartTag );\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( chars ) {\n\t\t\t\tindex = html.indexOf(\"<\");\n\n\t\t\t\tvar text = index < 0 ? html : html.substring( 0, index );\n\t\t\t\thtml = index < 0 ? \"\" : html.substring( index );\n\n\t\t\t\tif ( handler.chars )\n\t\t\t\t\thandler.chars( text );\n\t\t\t}\n\n\t\t} else {\n\t\t\thtml = html.replace(new RegExp(\"(.*)<\\/\" + stack.last() + \"[^>]*>\"), function(all, text){\n\t\t\t\ttext = text.replace(/<!--(.*?)-->/g, \"$1\")\n\t\t\t\t\t.replace(/<!\\[CDATA\\[(.*?)]]>/g, \"$1\");\n\n\t\t\t\tif ( handler.chars )\n\t\t\t\t\thandler.chars( text );\n\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\tparseEndTag( \"\", stack.last() );\n\t\t}\n\n\t\tif ( html === last )\n\t\t\tthrow \"Parse Error: \" + html;\n\t\tlast = html;\n\t}\n\n\t// Clean up any remaining tags\n\tparseEndTag();\n};","'use strict';\n\nvar htmlPurifier = function(settings){\n    var allowHeaders = true;\n    var stack = [];\n    var active_elements = [];\n    var customTags = {};\n    var root;\n    var insertion_mode;\n    var noFormatting;\n    var preferB_I = false;\n    var preferStrong_Em = false;\n    var withoutTags;\n\n\n    var scope_markers = {'td': true, 'th': true, 'caption': true};\n    var tags_with_implied_end = {'li': true, 'p': true};\n    var allowed_attributes = {\n        all_elements: ['class', 'style', 'id'],\n        a: ['href', 'target', 'title', 'name', 'rel', 'rev', 'type'],\n        blockquote: ['cite'],\n        img: ['src', 'alt', 'title', 'longdesc'],\n        td: ['colspan'],\n        th: ['colspan'],\n        tr: ['rowspan'],\n        table: ['border']\n    };\n    var allowed_attributes_as_hash;\n    var selfClosing = {\n        br: true,\n        hr: true,\n        img: true\n    };\n    var dontIndent = {\n        strong: true,\n        b: true,\n        i: true,\n        em: true,\n        pre: true\n    };\n    var indent = false;\n    var indent_string = \"    \";\n    var indentation = function (depth, switchOff) {\n        if (noFormatting) return \"\";\n        if (!indent) return \"\";\n        if (switchOff) indent = false;\n        var result = \"\\n\";\n        for (var i = 0; i < depth; i++) {\n            result += indent_string;\n        }\n        return result;\n    };\n\n    var TextNode = function (text) {\n        this.text = text.replace(/\\s+/g, ' ');\n    };\n\n    TextNode.prototype = {\n        isEmpty: function () {\n            return !this.text;\n        },\n        textContent: function () {\n            return this.text;\n        },\n        toString: function () {\n            return this.isEmpty() ? '' : indentation(this.depth(), true) + this.text.replace(/(&nbsp;)+/, ' ');\n        },\n        depth: function () {\n            return this.parent.depth() + 1;\n        }\n    };\n\n    var Node = function (name) {\n        this.name = name;\n        this.children = [];\n        this.attributes = {};\n    };\n\n    Node.prototype = {\n        appendChild: function (child) {\n            this.children.push(child);\n            child.parent = this;\n            return child;\n        },\n        removeChild: function (child) {\n            for (var i = 0, len = this.children.length; i < len; i++) {\n                if (this.children[i] === child) {\n                    return this.children.splice(i, i);\n                }\n            }\n            return null;\n        },\n        lastChild: function () {\n            return this.children[this.children.length - 1];\n        },\n        clone: function () {\n            var clone = new Node(this.name);\n            for (var i in this.attributes) {\n                clone.attributes[i] = this.attributes[i];\n            }\n            return clone;\n        },\n        startTag: function () {\n            return \"<\" + this.name + this.attributeString() + \">\";\n        },\n        endTag: function () {\n            return \"</\" + this.name + \">\";\n        },\n        selfClosingTag: function () {\n            return \"<\" + this.name + this.attributeString() + \"/>\";\n        },\n        attributeString: function () {\n            var string = \"\";\n\n            var allowed_for_tag = allowed_attributes_as_hash[this.name] || {};\n            var allowed_for_all = allowed_attributes_as_hash['all_elements'] || {};\n\n            for (var i = 0, len = (this.attributes || []).length; i < len; i++) {\n                var name = this.attributes[i].name;\n                var value = this.attributes[i].value;\n                if ((allowed_for_tag[name] || allowed_for_all[name]) && value) {\n                    if (name === 'href') {\n                        // don't allow links to anywhere other than http(s)\n                        // because they could contain JavaScript (javascript:) or other bad things!\n                        var permittedRegex = /^https?:\\/\\//i;\n                        if (!permittedRegex.test(value)) {\n                            // if not allowed, set the attribute to be empty\n                            value = '';\n                        }\n                    }\n\n                    string += \" \" + name + \"=\\\"\" + value + \"\\\"\";\n                }\n            }\n            return string;\n        },\n        innerHTML: function () {\n            var string = \"\";\n            for (var i = 0, len = this.children.length; i < len; i++) {\n                string += this.children[i];\n            }\n            return string;\n        },\n        textContent: function () {\n            var text = \"\";\n            for (var i = 0, len = this.children.length; i < len; i++) {\n                if (this.children[i] instanceof TextNode) {\n                    text += this.children[i].text;\n                }\n            }\n            return text;\n        },\n        toString: function () {\n            if (this.isEmpty()) return '';\n\n            var string = \"\";\n            if (selfClosing[this.name]) {\n                string = indentation(this.depth(), true) + this.selfClosingTag();\n            } else {\n                indent = dontIndent[this.name] ? indent : true;\n                string = indentation(this.depth(), dontIndent[this.name]) + this.startTag() + this.innerHTML();\n                indent = dontIndent[this.name] ? indent : true;\n                string += indentation(this.depth()) + this.endTag();\n            }\n            return string;\n        },\n        depth: function () {\n            return this.parent ? this.parent.depth() + 1 : -1;\n        },\n        isEmpty: function () {\n            // Zaption mod: self-closing elements never count as empty\n            // otherwise <p><br/></p> gets removed entirely\n            if (selfClosing[this.name]) {\n                return false;\n            }\n\n            if (typeof(this._isEmpty) === \"undefined\") {\n                this._isEmpty = true;\n                for (var i = 0, len = this.children.length; i < len; i++) {\n                    if (!this.children[i].isEmpty()) {\n                        this._isEmpty = false;\n                        break;\n                    }\n                }\n            }\n            return this._isEmpty;\n        }\n    };\n\n    function init(settings) {\n        var modes = {\n            InBody: InBody,\n            InCell: InCell,\n            InRow: InRow,\n            InTableBody: InTableBody,\n            InColumnGroup: InColumnGroup,\n            InCaption: InCaption,\n            InTable: InTable\n        };\n        if(!settings.insertion_mode || !modes[settings.insertion_mode]){\n            settings.insertion_mode = 'InBody';\n        };\n        insertion_mode = modes[settings.insertion_mode];\n\n        _.extend(allowed_attributes, settings.allowed_attributes);\n        _.extend(customTags, settings.customTags);\n        _.extend(selfClosing, settings.selfClosingTags);\n\n        root = new Node('html');\n        stack = [root];\n        active_elements = [];\n        allowed_attributes_as_hash = {};\n\n\n        var attr, i;\n        for (var key in allowed_attributes) {\n            allowed_attributes_as_hash[key] = {};\n            for (i in allowed_attributes['all_elements']) {\n                attr = allowed_attributes['all_elements'][i];\n                allowed_attributes_as_hash[key][attr] = true;\n            }\n            if (key === 'all_elements') {\n                continue;\n            }\n            for (i in allowed_attributes[key]) {\n                attr = allowed_attributes[key][i];\n                allowed_attributes_as_hash[key][attr] = true;\n            }\n        }\n\n        noFormatting = !!settings.noFormatting;\n        preferStrong_Em = !!settings.preferStrong_Em;\n        preferB_I = !preferStrong_Em && !!settings.preferB_I;\n        allowHeaders = !settings.noHeaders;\n        withoutTags = {};\n\n        if(typeof settings.withoutTags === 'string' && settings.withoutTags){\n            settings.withoutTags = [settings.withoutTags];\n        }\n\n        if(settings.withoutTags && settings.withoutTags.length){\n            for (var i = settings.withoutTags.length -1 ; i >= 0; i--) {\n                withoutTags[settings.withoutTags[i]] = true;\n            }\n        }\n    }\n\n    function current_node() {\n        return _.last(stack);\n    }\n\n    function reconstruct_the_active_formatting_elements() {\n        if (active_elements.length === 0 || _.contains(stack, _.last(active_elements))) {\n            return;\n        }\n        var entry;\n        for (var i = active_elements.length; i > 0; i--) {\n            entry = active_elements[i - 1];\n            if (_.contains(stack, entry)) {\n                break;\n            }\n        }\n        do {\n            var clone = entry.clone();\n            current_node().appendChild(clone);\n            stack.push(clone);\n            active_elements[i] = clone;\n            i += 1;\n        } while (i !== active_elements.length);\n    }\n\n    function has_element_with(arr_of_elements, tagName) {\n        for (var i = arr_of_elements.length; i > 0; i--) {\n            if (arr_of_elements[i - 1].name === tagName) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function in_scope(tagName) {\n        return has_element_with(stack, tagName);\n    }\n\n    function in_table_scope(tagName) {\n        for (var i = stack.length; i > 0; i--) {\n            var nodeTag = stack[i - 1].name;\n            if (nodeTag === tagName) {\n                return true;\n            } else if (nodeTag === 'table' || nodeTag === 'html') {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    function insert_html_element_for(tagName, attrs) {\n        var node = new Node(tagName);\n        node.attributes = attrs;\n        current_node().appendChild(node);\n        stack.push(node);\n        return node;\n    }\n\n    function generate_implied_end_tags(exception) {\n        var tagName = current_node().name;\n        while (tags_with_implied_end[tagName] && tagName !== exception) {\n            end(tagName);\n            tagName = current_node().name;\n        }\n    }\n\n    function trim_to_1_space(str) {\n        return str.replace(/^\\s+/, ' ').replace(/\\s+$/, ' ');\n    }\n\n    function clear_stack_to_table_context() {\n        clear_stack_to_context_by_tags(['table', 'html']);\n    }\n\n    function clear_stack_to_table_body_context() {\n        clear_stack_to_context_by_tags(['tbody', 'tfoot', 'thead', 'html']);\n    }\n\n    function clear_stack_to_table_row_context() {\n        clear_stack_to_context_by_tags(['tr', 'html']);\n    }\n\n    function clear_stack_to_context_by_tags(tags) {\n        while (!_.contains(tags, current_node().name)) {\n            stack.pop();\n        }\n    }\n\n    function clear_active_elements_to_last_marker() {\n        var entry;\n        do {\n            entry = active_elements.pop();\n        } while (!scope_markers[entry.name]);\n    }\n\n    function reset_insertion_mode() {\n        var last = false;\n        var node;\n        for (var i = stack.length - 1; i >= 0; i--) {\n            node = stack[i];\n            if (node === stack[0]) {\n                last = true;\n            }\n            switch (node.name) {\n                case 'th':\n                case 'td':\n                    if (!last) {\n                        insertion_mode = InCell;\n                        return;\n                    }\n                case 'tr':\n                    insertion_mode = InRow;\n                    return;\n                case 'tbody':\n                case 'thead':\n                case 'tfoot':\n                    insertion_mode = InTableBody;\n                    return;\n                case 'caption':\n                    insertion_mode = InCaption;\n                    return;\n                case 'colgroup':\n                    insertion_mode = InColumnGroup;\n                    return;\n                case 'table':\n                    insertion_mode = InTable;\n                    return;\n                default:\n                    if (last) {\n                        insertion_mode = InBody;\n                        return;\n                    }\n            }\n        }\n    }\n\n    function close_the_cell() {\n        if (in_table_scope('td')) {\n            end('td');\n        } else {\n            end('th');\n        }\n    }\n\n    function start(tagName, attrs, unary) {\n        insertion_mode.insertion_mode_start(tagName, attrs, unary);\n    }\n\n    function end(tagName) {\n        insertion_mode.insertion_mode_end(tagName);\n    }\n\n    function chars(text) {\n        if (typeof(text) === 'undefined') {\n            return;\n        }\n        text = text.replace(/\\n\\s*\\n\\s*\\n*/g, '\\n\\n').replace(/(^\\n\\n|\\n\\n$)/g, '');\n        var paragraphs = text.split('\\n\\n');\n        var trimmedText;\n        if (paragraphs.length > 1) {\n            for (var i in paragraphs) {\n                start('p');\n                reconstruct_the_active_formatting_elements();\n                trimmedText = trim_to_1_space(paragraphs[i]);\n                current_node().appendChild(new TextNode(trimmedText));\n                end('p');\n            }\n        } else {\n            if (text.match(/^\\s*$/g) && current_node().children.length && current_node().lastChild().name === 'br') {\n                return;\n            }\n            reconstruct_the_active_formatting_elements();\n            trimmedText = trim_to_1_space(paragraphs[0]);\n            current_node().appendChild(new TextNode(trimmedText));\n        }\n    }\n\n    var InBody = {\n        insertion_mode_start: function (tagName, attrs) {\n            var node;\n            tagName = tagName.toLowerCase();\n            if (withoutTags[tagName]) {\n                return;\n            }\n            if (preferStrong_Em) {\n                switch (tagName) {\n                    case 'b':\n                        start('strong');\n                        return;\n                    case 'i':\n                        start('em');\n                        return;\n                }\n            } else if (preferB_I) {\n                switch (tagName) {\n                    case 'strong':\n                        start('b');\n                        return;\n                    case 'em':\n                        start('i');\n                        return;\n                }\n            }\n            switch (tagName) {\n                case 'h1':\n                case 'h2':\n                case 'h3':\n                case 'h4':\n                case 'h5':\n                case 'h6':\n                case 'h7':\n                    if (!allowHeaders) {\n                        start('p');\n                        if (preferB_I) {\n                            start('b');\n                        } else {\n                            start('strong');\n                        }\n                        return;\n                    }\n                case 'blockquote':\n                case 'ol':\n                case 'p':\n                case 'ul':\n                case 'pre': // Techically PRE shouldn't be in this groups, since newlines should be ignored after a pre tag\n                    if (in_scope('p')) {\n                        end('p');\n                    }\n                    insert_html_element_for(tagName, attrs);\n                    return;\n                case 'li':\n                    if (in_scope('p')) {\n                        end('p');\n                    }\n                    node = current_node();\n                    while (node.name === 'li') {\n                        stack.pop();\n                    }\n                    insert_html_element_for(tagName, attrs);\n                    return;\n                case 'a':\n                    for (var i = active_elements.length; i > 0; i--) {\n                        if (active_elements[i - 1].name === 'a') {\n                            end('a');\n                            active_elements.splice(i - 1, 1);\n                        }\n                    }\n                    reconstruct_the_active_formatting_elements();\n                    node = insert_html_element_for(tagName, attrs);\n                    active_elements.push(node);\n                    return;\n                case 'strong':\n                case 'b':\n                case 'em':\n                case 'i':\n                case 'u':\n                case 'span':\n                    reconstruct_the_active_formatting_elements();\n                    node = insert_html_element_for(tagName, attrs);\n                    active_elements.push(node);\n                    return;\n                case 'table':\n                    if (in_scope('p')) {\n                        end('p');\n                    }\n                    insert_html_element_for(tagName, attrs);\n                    insertion_mode = InTable;\n                    return;\n                case 'br':\n                case 'img':\n                    reconstruct_the_active_formatting_elements();\n                    insert_html_element_for(tagName, attrs);\n                    stack.pop();\n                    return;\n            }\n            if (customTags[tagName]) {\n                if (selfClosing[tagName]) {\n                    reconstruct_the_active_formatting_elements();\n                    insert_html_element_for(tagName, attrs);\n                    stack.pop();\n                    return;\n                } else {\n                    reconstruct_the_active_formatting_elements();\n                    node = insert_html_element_for(tagName, attrs);\n                    active_elements.push(node);\n                    return;\n                }\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof tagName === 'undefined') {\n                return;\n            }\n            var node;\n            tagName = tagName.toLowerCase();\n            if (!withoutTags[tagName]) {\n                if (preferStrong_Em) {\n                    switch (tagName) {\n                        case 'b':\n                            end('strong');\n                            return;\n                        case 'i':\n                            end('em');\n                            return;\n                    }\n                } else if (preferB_I) {\n                    switch (tagName) {\n                        case 'strong':\n                            end('b');\n                            return;\n                        case 'em':\n                            end('i');\n                            return;\n                    }\n                }\n                switch (tagName) {\n                    case 'h1':\n                    case 'h2':\n                    case 'h3':\n                    case 'h4':\n                    case 'h5':\n                    case 'h6':\n                    case 'h7':\n                        if (!allowHeaders) {\n                            if (preferB_I) {\n                                end('b');\n                            } else {\n                                end('strong');\n                            }\n                            end('p');\n                            return;\n                        }\n                        if (in_scope(tagName)) {\n                            generate_implied_end_tags();\n                            do {\n                                node = stack.pop();\n                            } while (node.name !== tagName);\n                        }\n                        return;\n                    case 'blockquote':\n                    case 'ol':\n                    case 'ul':\n                    case 'pre': // Techically PRE shouldn't be in this groups, since newlines should be ignored after a pre tag\n                        if (in_scope(tagName)) {\n                            generate_implied_end_tags();\n                        }\n                        if (in_scope(tagName)) {\n                            do {\n                                node = stack.pop();\n                            } while (node.name !== tagName);\n                        }\n                        return;\n                    case 'p':\n                        if (in_scope(tagName)) {\n                            generate_implied_end_tags(tagName);\n                        }\n                        var no_p_in_scope = true;\n                        while (in_scope(tagName)) {\n                            no_p_in_scope = false;\n                            node = stack.pop();\n                        }\n                        if (no_p_in_scope) {\n                            start('p', [], false);\n                            end('p');\n                        }\n                        return;\n                    case 'li':\n                        if (in_scope(tagName)) {\n                            generate_implied_end_tags(tagName);\n                        }\n                        if (in_scope(tagName)) {\n                            do {\n                                node = stack.pop();\n                            } while (node.name !== tagName);\n                        }\n                        return;\n                    case 'a':\n                    case 'i':\n                    case 'em':\n                    case 'strong':\n                    case 'b':\n                    case 'u':\n                    case 'span':\n                        for (var i = active_elements.length; i > 0; i--) {\n                            if (active_elements[i - 1].name === tagName) {\n                                node = active_elements[i - 1];\n                                break;\n                            }\n                        }\n                        if (typeof(node) === 'undefined' || !_.contains(stack, node)) {\n                            return;\n                        }\n                        // Step 2 from the algorithm in the HTML5 spec will never be necessary with the tags we allow\n                        var popped_node;\n                        do {\n                            popped_node = stack.pop();\n                        } while (popped_node !== node);\n                        active_elements.splice(i - 1, 1);\n                        return;\n\n                }\n                if (customTags[tagName] && !selfClosing[tagName]) {\n                    for (var i = active_elements.length; i > 0; i--) {\n                        if (active_elements[i - 1].name === tagName) {\n                            node = active_elements[i - 1];\n                            break;\n                        }\n                    }\n                    if (typeof(node) === 'undefined' || !_.contains(stack, node)) {\n                        return;\n                    }\n                    // Step 2 from the algorithm in the HTML5 spec will never be necessary with the tags we allow\n                    var popped_node;\n                    do {\n                        popped_node = stack.pop();\n                    } while (popped_node !== node);\n                    active_elements.splice(i - 1, 1);\n                    return;\n                }\n            }\n            node = current_node();\n            if (node.name === tagName) {\n                generate_implied_end_tags();\n                while (stack.length > 0 && node !== current_node()) {\n                    stack.pop();\n                }\n            }\n        }\n    };\n\n    var InTable = {\n        insertion_mode_start: function (tagName, attrs, unary) {\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'caption':\n                    clear_stack_to_table_context();\n                    active_elements.push(insert_html_element_for(tagName, attrs));\n                    insertion_mode = InCaption;\n                    return;\n                case 'colgroup':\n                    clear_stack_to_table_context();\n                    insert_html_element_for(tagName, attrs);\n                    insertion_mode = InColumnGroup;\n                    return;\n                case 'col':\n                    start('colgroup');\n                    start(tagName, attrs, unary);\n                    return;\n                case 'tbody':\n                case 'tfoot':\n                case 'thead':\n                    clear_stack_to_table_context();\n                    insert_html_element_for(tagName, attrs);\n                    insertion_mode = InTableBody;\n                    return;\n                case 'td':\n                case 'th':\n                case 'tr':\n                    start('tbody');\n                    start(tagName, attrs, unary);\n                    return;\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof(tagName) === undefined) {\n                return;\n            }\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'table':\n                    if (in_table_scope('table')) {\n                        var node;\n                        do {\n                            node = stack.pop();\n                        } while (node.name !== 'table');\n                    }\n                    reset_insertion_mode();\n                    return;\n            }\n        }\n    };\n\n    var InCaption = {\n        insertion_mode_start: function (tagName, attrs, unary) {\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'caption':\n                case 'col':\n                case 'colgroup':\n                case 'tbody':\n                case 'td':\n                case 'tfoot':\n                case 'th':\n                case 'thead':\n                case 'tr':\n                    end('caption');\n                    start(tagName);\n                    return;\n                default:\n                    InBody.insertion_mode_start(tagName, attrs, unary);\n                    return;\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof(tagName) === undefined) {\n                return;\n            }\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'caption':\n                    if (in_table_scope('caption')) {\n                        generate_implied_end_tags();\n                        if (current_node().name === 'caption') {\n                            var node;\n                            do {\n                                node = stack.pop();\n                            } while (node.name !== 'caption');\n                            clear_active_elements_to_last_marker();\n                            insertion_mode = InTable;\n                        }\n                    }\n                    return;\n                case \"body\":\n                case \"col\":\n                case \"colgroup\":\n                case \"html\":\n                case \"tbody\":\n                case \"td\":\n                case \"tfoot\":\n                case \"th\":\n                case \"thead\":\n                case \"tr\":\n                    return;\n                case 'table':\n                    end('caption');\n                    end('table');\n                    return;\n                default:\n                    InBody.insertion_mode_end(tagName);\n                    return;\n            }\n        }\n    };\n\n    var InColumnGroup = {\n        insertion_mode_start: function (tagName, attrs, unary) {\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'html':\n                    InBody.insertion_mode_start(tagName, attrs, unary);\n                    return;\n                case 'col':\n                    insert_html_element_for(tagName, attrs);\n                    stack.pop();\n                    return;\n                default:\n                    end('colgroup');\n                    start(tagName);\n                    return;\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof(tagName) === undefined) {\n                return;\n            }\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'colgroup':\n                    if (current_node().name !== 'html') {\n                        stack.pop();\n                        insertion_mode = InTable;\n                    }\n                    return;\n                case 'col':\n                    return;\n                default:\n                    end('colgroup');\n                    end(tagName);\n                    return;\n            }\n        }\n    };\n\n    var InTableBody = {\n        insertion_mode_start: function (tagName, attrs, unary) {\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'tr':\n                    clear_stack_to_table_body_context();\n                    insert_html_element_for(tagName, attrs);\n                    insertion_mode = InRow;\n                    return;\n                case 'th':\n                case 'td':\n                    start('tr');\n                    start(tagName, attrs, unary);\n                    return;\n                case \"caption\":\n                case \"col\":\n                case \"colgroup\":\n                case \"tbody\":\n                case \"tfoot\":\n                case \"thead\":\n                    if (in_table_scope('tbody') || in_table_scope('thead') || in_table_scope('tfoot')) {\n                        clear_stack_to_table_body_context();\n                        end(current_node().name);\n                        start(tagName, attrs, unary);\n                    }\n                    return;\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof(tagName) === undefined) {\n                return;\n            }\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'tbody':\n                case 'tfoot':\n                case 'thead':\n                    if (in_table_scope(tagName)) {\n                        clear_stack_to_table_body_context();\n                        stack.pop();\n                        insertion_mode = InTable;\n                    }\n                    return;\n                case 'table':\n                    if (in_table_scope('tbody') || in_table_scope('thead') || in_table_scope('tfoot')) {\n                        clear_stack_to_table_body_context();\n                        end(current_node().name);\n                        end(tagName);\n                    }\n                    return;\n                case \"body\":\n                case \"caption\":\n                case \"col\":\n                case \"colgroup\":\n                case \"html\":\n                case \"td\":\n                case \"th\":\n                case \"tr\":\n                    return;\n                default:\n                    InTable.insertion_mode_end(tagName);\n                    return;\n            }\n        }\n    };\n\n    var InRow = {\n        insertion_mode_start: function (tagName, attrs, unary) {\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'th':\n                case 'td':\n                    clear_stack_to_table_row_context();\n                    var node = insert_html_element_for(tagName, attrs);\n                    insertion_mode = InCell;\n                    active_elements.push(node);\n                    return;\n                case \"caption\":\n                case \"col\":\n                case \"colgroup\":\n                case \"tbody\":\n                case \"tfoot\":\n                case \"thead\":\n                case \"tr\":\n                    end('tr');\n                    start(tagName, attrs, unary);\n                    return;\n                default:\n                    InTable.insertion_mode_start(tagName, attrs, unary);\n                    return;\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof(tagName) === undefined) {\n                return;\n            }\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case 'tr':\n                    if (in_table_scope(tagName)) {\n                        clear_stack_to_table_row_context();\n                        stack.pop();\n                        insertion_mode = InTableBody;\n                    }\n                    return;\n                case 'table':\n                    end('tr');\n\n                    // this line was in the original source but attrs/unary are not defined\n                    // so not sure what to do with it. how was this working?\n                    // start(tagName, attrs, unary);\n                    return;\n                case \"tbody\":\n                case \"tfoot\":\n                case \"thead\":\n                    if (in_table_scope(tagName)) {\n                        end('tr');\n                        end(tagName);\n                    }\n                    return;\n                case \"body\":\n                case \"caption\":\n                case \"col\":\n                case \"colgroup\":\n                case \"html\":\n                case \"td\":\n                case \"th\":\n                    return;\n                default:\n                    InTable.insertion_mode_end(tagName);\n                    return;\n            }\n        }\n    };\n\n    var InCell = {\n        insertion_mode_start: function (tagName, attrs, unary) {\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case \"caption\":\n                case \"col\":\n                case \"colgroup\":\n                case \"tbody\":\n                case \"td\":\n                case \"tfoot\":\n                case \"th\":\n                case \"thead\":\n                case \"tr\":\n                    if (in_table_scope('td') || in_table_scope('th')) {\n                        close_the_cell();\n                        start(tagName, attrs, unary);\n                    }\n                    return;\n                default:\n                    InBody.insertion_mode_start(tagName, attrs, unary);\n                    return;\n            }\n        },\n\n        insertion_mode_end: function (tagName) {\n            if (typeof(tagName) === undefined) {\n                return;\n            }\n            tagName = tagName.toLowerCase();\n            switch (tagName) {\n                case \"td\":\n                case \"th\":\n                    if (in_table_scope(tagName)) {\n                        generate_implied_end_tags();\n                        if (current_node().name !== tagName) {\n                            return;\n                        }\n                        var node;\n                        do {\n                            node = stack.pop();\n                        } while (node.name !== tagName);\n\n                        clear_active_elements_to_last_marker();\n                        insertion_mode = InRow;\n                    }\n                    return;\n                case \"body\":\n                case \"caption\":\n                case \"col\":\n                case \"colgroup\":\n                case \"html\":\n                    return;\n                case \"table\":\n                case \"tbody\":\n                case \"tfoot\":\n                case \"thead\":\n                case \"tr\":\n                    if (in_table_scope(tagName)) {\n                        close_the_cell();\n                        end(tagName);\n                    }\n                    return;\n                default:\n                    InBody.insertion_mode_end(tagName);\n                    return;\n            }\n        }\n    };\n\n    init(settings);\n\n    return {\n        start: start,\n        end: end,\n        chars: chars,\n        getResult: function(){\n            return root.innerHTML().replace(/^\\s+/, '');\n        }\n    };\n\n};\n\n\nvar allowed_attributes = {};\nvar customTags = {};\nvar selfClosing = {};\n\n/* global UniHTML: true */\nUniHTML = {\n    /**\n     * Parse html string and calls callback in the same order as tags in html string are present.\n     * Method supports html5, including custom tags.\n     * @param html\n     * @param handler {Object} object of callbacks for example:\n     * {\n     *          // attributesOnTag is an Object like {name, value, escaped}\n     *      start: function(tagName, attributesOnTag, isSelfClosing), // open tag\n     *      end: function(tagName), // close\n     *      chars: function(text), // text between open and closing tag\n     *      comment: function(text) // text from comment\n     * }\n     * @throws Parse Error\n     */\n    parse: HTMLParser,\n    /**\n     * Cleanup dirty html from unknown/untrusted tags\n     * @param html {string} html string to purify\n     * @param settings {Object} noFormatting, preferStrong_Em, preferB_I, noHeaders, withoutTags\n     * @returns {HTML|string|void}\n     */\n    purify: function (html, settings) {\n        if (typeof settings !== 'object') {\n            settings = {};\n        }\n        settings = _.extend({\n            allowed_attributes: allowed_attributes,\n            customTags: customTags,\n            selfClosingTags: selfClosing\n        }, settings);\n        var purifierInstance = htmlPurifier(settings);\n\n        try {\n            HTMLParser(html, {\n                start: purifierInstance.start,\n                end: purifierInstance.end,\n                chars: purifierInstance.chars\n            });\n        } catch (e) {\n            if (!settings.catchErrors) {\n                throw e;\n            }\n        }\n        return purifierInstance.getResult();\n    },\n    /**\n     * Sets new default allowed attributes for one or all tags\n     * (it can be overridden by setting 'allowed_attributes' in purify)\n     * @param attributesArray {Array} Array of names of attributes\n     * @param tag {string=} [tag=all_elements]\n     */\n    setNewAllowedAttributes: function (attributesArray, tag) {\n        if (!tag) {\n            tag = 'all_elements';\n        }\n        if (!attributesArray) {\n            attributesArray = [];\n        }\n        if (typeof attributesArray === 'string') {\n            attributesArray = [attributesArray];\n        }\n        allowed_attributes[tag] = attributesArray;\n    },\n    /**\n     * Adds new default allowed html tag\n     * (it can be overridden by settings 'customTags', 'selfClosingTags' in purify method)\n     * @param tagName {string}\n     * @param isSelfClosing {boolean=} a void tags like: img, hr, area\n     */\n    addNewAllowedTag: function (tagName, isSelfClosing) {\n        customTags[tagName] = true;\n        if (isSelfClosing) {\n            selfClosing[tagName] = true;\n        }\n    }\n\n};"]}