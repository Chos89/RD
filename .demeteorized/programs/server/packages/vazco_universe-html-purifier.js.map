{"version":3,"sources":["vazco:universe-html-purifier/HTMLParser.js","vazco:universe-html-purifier/HTMLPurifier.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,E;AACA,wC;AACA,4G;AACA,2D;;AAEA,yE;AACA,G;;AAEA,2G;AACA,gH;AACA,+B;AACA,yF;;AAEA,sB;AACA,sC;AACA,yC;AACA,yB;AACA,Y;AACA,C;;AAEA,mI;;AAEA,oT;;AAEA,6Q;;AAEA,mD;AACA,+B;AACA,4E;;AAEA,kE;AACA,kI;;AAEA,0C;AACA,sC;;AAEA,wC;AACA,kD;AACA,yB;AACA,iC;AACA,G;;AAEA,sD;AACA,2B;AACA,qD;AACA,oC;AACA,I;AACA,G;;AAEA,2D;AACA,8B;AACA,G;;AAEA,sC;;AAEA,e;AACA,yB;;AAEA,wB;AACA,kB;;AAEA,6C;AACA,6C;AACA,kC;AACA,kC;AACA,iC;;AAEA,gB;AACA,gB;AACA,kB;AACA,wD;AACA,O;AACA,M;;AAEA,uB;AACA,2C;AACA,G;AACA,E;;AAEA,uC;AACA,U;;AAEA,2C;AACA,iB;AACA,W;AACA,G;;AAEA,iD;AACA,M;AACA,kD;AACA,mC;AACA,W;;AAEA,mB;AACA,+C;AACA,kD;AACA,sB;AACA,+B;;AAEA,6C;AACA,sB;AACA,G;AACA,E;;AAEA,iB;AACA,e;AACA,qD;AACA,oD;;AAEA,a;AACA,sC;AACA,gC;;AAEA,uB;AACA,2B;AACA,oD;AACA,wC;AACA,mB;AACA,K;;AAEA,a;AACA,2C;AACA,iC;;AAEA,kB;AACA,8C;AACA,6C;AACA,mB;AACA,K;;AAEA,e;AACA,0C;AACA,mC;;AAEA,kB;AACA,8C;AACA,iD;AACA,mB;AACA,K;AACA,I;;AAEA,iB;AACA,8B;;AAEA,6D;AACA,oD;;AAEA,wB;AACA,2B;AACA,I;;AAEA,U;AACA,4F;AACA,8C;AACA,4C;;AAEA,wB;AACA,2B;;AAEA,c;AACA,M;;AAEA,mC;AACA,G;;AAEA,sB;AACA,gC;AACA,c;AACA,E;;AAEA,+B;AACA,e;AACA,E;;;;;;;;;;;;;;;;;;AC5KA,wB;AACA,e;AACA,yB;AACA,oB;AACA,S;AACA,mB;AACA,iB;AACA,sB;AACA,4B;AACA,gB;;;AAGA,8D;AACA,oD;AACA,0B;AACA,2C;AACA,iE;AACA,yB;AACA,6C;AACA,oB;AACA,oB;AACA,oB;AACA,qB;AACA,E;AACA,+B;AACA,mB;AACA,a;AACA,a;AACA,a;AACA,E;AACA,kB;AACA,iB;AACA,Y;AACA,Y;AACA,a;AACA,a;AACA,E;AACA,mB;AACA,2B;AACA,+C;AACA,gC;AACA,2B;AACA,kC;AACA,sB;AACA,qC;AACA,gC;AACA,K;AACA,kB;AACA,E;;AAEA,gC;AACA,0C;AACA,E;;AAEA,sB;AACA,0B;AACA,0B;AACA,M;AACA,8B;AACA,yB;AACA,M;AACA,2B;AACA,2G;AACA,M;AACA,wB;AACA,uC;AACA,K;AACA,E;;AAEA,4B;AACA,qB;AACA,uB;AACA,yB;AACA,E;;AAEA,kB;AACA,mC;AACA,kC;AACA,4B;AACA,qB;AACA,M;AACA,mC;AACA,mE;AACA,6C;AACA,kD;AACA,a;AACA,S;AACA,oB;AACA,M;AACA,4B;AACA,uD;AACA,M;AACA,wB;AACA,wC;AACA,wC;AACA,qD;AACA,S;AACA,qB;AACA,M;AACA,2B;AACA,8D;AACA,M;AACA,yB;AACA,sC;AACA,M;AACA,iC;AACA,+D;AACA,M;AACA,kC;AACA,wB;;AAEA,0E;AACA,+E;;AAEA,6E;AACA,+C;AACA,iD;AACA,4E;AACA,sC;AACA,uE;AACA,+F;AACA,yD;AACA,sD;AACA,wE;AACA,mC;AACA,qB;AACA,iB;;AAEA,4D;AACA,a;AACA,S;AACA,sB;AACA,M;AACA,4B;AACA,wB;AACA,mE;AACA,uC;AACA,S;AACA,sB;AACA,M;AACA,8B;AACA,sB;AACA,mE;AACA,uD;AACA,8C;AACA,a;AACA,S;AACA,oB;AACA,M;AACA,2B;AACA,sC;;AAEA,wB;AACA,qC;AACA,6E;AACA,gB;AACA,2D;AACA,2G;AACA,2D;AACA,gE;AACA,S;AACA,sB;AACA,M;AACA,wB;AACA,0D;AACA,M;AACA,0B;AACA,kE;AACA,uD;AACA,qC;AACA,yB;AACA,S;;AAEA,oD;AACA,iC;AACA,uE;AACA,kD;AACA,0C;AACA,0B;AACA,iB;AACA,a;AACA,S;AACA,6B;AACA,K;AACA,E;;AAEA,yB;AACA,4B;AACA,mB;AACA,yB;AACA,oC;AACA,gB;AACA,yC;AACA,6C;AACA,uD;AACA,yD;AACA,yD;AACA,S;AACA,qC;AACA,qB;AACA,S;AACA,4C;AACA,8C;AACA,yD;AACA,S;AACA,K;;AAEA,2C;AACA,iD;AACA,yD;AACA,uC;AACA,qB;;AAEA,yE;AACA,sD;AACA,K;;AAEA,4D;AACA,oE;AACA,wD;AACA,S;AACA,K;AACA,C;;AAEA,wB;AACA,0B;AACA,oB;AACA,oB;AACA,K;AACA,yB;AACA,C;;AAEA,8B;AACA,0C;AACA,yC;AACA,K;AACA,iB;AACA,C;;AAEA,yB;AACA,0B;AACA,C;;AAEA,uD;AACA,oF;AACA,e;AACA,K;AACA,c;AACA,sD;AACA,uC;AACA,qC;AACA,kB;AACA,S;AACA,K;AACA,Q;AACA,kC;AACA,0C;AACA,0B;AACA,mC;AACA,e;AACA,2C;AACA,C;;AAEA,qD;AACA,sD;AACA,sD;AACA,wB;AACA,S;AACA,K;AACA,iB;AACA,C;;AAEA,4B;AACA,4C;AACA,C;;AAEA,kC;AACA,4C;AACA,wC;AACA,kC;AACA,wB;AACA,+D;AACA,yB;AACA,S;AACA,K;AACA,iB;AACA,C;;AAEA,kD;AACA,iC;AACA,4B;AACA,qC;AACA,qB;AACA,gB;AACA,C;;AAEA,+C;AACA,sC;AACA,qE;AACA,qB;AACA,sC;AACA,K;AACA,C;;AAEA,+B;AACA,yD;AACA,C;;AAEA,yC;AACA,sD;AACA,C;;AAEA,8C;AACA,wE;AACA,C;;AAEA,6C;AACA,mD;AACA,C;;AAEA,+C;AACA,kD;AACA,oB;AACA,K;AACA,C;;AAEA,iD;AACA,c;AACA,Q;AACA,sC;AACA,yC;AACA,C;;AAEA,iC;AACA,qB;AACA,a;AACA,iD;AACA,wB;AACA,gC;AACA,wB;AACA,S;AACA,4B;AACA,sB;AACA,sB;AACA,4B;AACA,4C;AACA,2B;AACA,iB;AACA,sB;AACA,uC;AACA,uB;AACA,yB;AACA,yB;AACA,yB;AACA,6C;AACA,uB;AACA,2B;AACA,2C;AACA,uB;AACA,4B;AACA,+C;AACA,uB;AACA,yB;AACA,yC;AACA,uB;AACA,oB;AACA,2B;AACA,4C;AACA,2B;AACA,iB;AACA,S;AACA,K;AACA,C;;AAEA,2B;AACA,+B;AACA,kB;AACA,Y;AACA,kB;AACA,K;AACA,C;;AAEA,uC;AACA,+D;AACA,C;;AAEA,uB;AACA,+C;AACA,C;;AAEA,sB;AACA,uC;AACA,e;AACA,K;AACA,gF;AACA,wC;AACA,oB;AACA,gC;AACA,mC;AACA,uB;AACA,yD;AACA,yD;AACA,kE;AACA,qB;AACA,S;AACA,Y;AACA,iH;AACA,mB;AACA,S;AACA,qD;AACA,qD;AACA,8D;AACA,K;AACA,C;;AAEA,c;AACA,qD;AACA,iB;AACA,wC;AACA,mC;AACA,mB;AACA,S;AACA,8B;AACA,8B;AACA,yB;AACA,oC;AACA,2B;AACA,yB;AACA,gC;AACA,2B;AACA,a;AACA,+B;AACA,8B;AACA,8B;AACA,+B;AACA,2B;AACA,0B;AACA,+B;AACA,2B;AACA,a;AACA,S;AACA,0B;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,+B;AACA,oC;AACA,mC;AACA,4B;AACA,wC;AACA,qB;AACA,2B;AACA,iB;AACA,8B;AACA,sB;AACA,qB;AACA,sB;AACA,uH;AACA,oC;AACA,6B;AACA,iB;AACA,wD;AACA,uB;AACA,sB;AACA,oC;AACA,6B;AACA,iB;AACA,sC;AACA,4C;AACA,gC;AACA,iB;AACA,wD;AACA,uB;AACA,qB;AACA,kE;AACA,8D;AACA,iC;AACA,yD;AACA,qB;AACA,iB;AACA,6D;AACA,+D;AACA,2C;AACA,uB;AACA,0B;AACA,qB;AACA,sB;AACA,qB;AACA,qB;AACA,wB;AACA,6D;AACA,+D;AACA,2C;AACA,uB;AACA,yB;AACA,oC;AACA,6B;AACA,iB;AACA,wD;AACA,yC;AACA,uB;AACA,sB;AACA,uB;AACA,6D;AACA,wD;AACA,4B;AACA,uB;AACA,S;AACA,kC;AACA,uC;AACA,6D;AACA,wD;AACA,4B;AACA,uB;AACA,oB;AACA,6D;AACA,+D;AACA,2C;AACA,uB;AACA,a;AACA,S;AACA,M;;AAEA,4C;AACA,6C;AACA,mB;AACA,S;AACA,iB;AACA,wC;AACA,oC;AACA,kC;AACA,kC;AACA,6B;AACA,sC;AACA,+B;AACA,6B;AACA,kC;AACA,+B;AACA,iB;AACA,mC;AACA,kC;AACA,kC;AACA,iC;AACA,+B;AACA,8B;AACA,iC;AACA,+B;AACA,iB;AACA,a;AACA,8B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,wC;AACA,wC;AACA,qC;AACA,gC;AACA,0C;AACA,yB;AACA,iC;AACA,+B;AACA,qB;AACA,4C;AACA,oD;AACA,4B;AACA,+C;AACA,wD;AACA,qB;AACA,2B;AACA,kC;AACA,0B;AACA,0B;AACA,2H;AACA,4C;AACA,oD;AACA,qB;AACA,4C;AACA,4B;AACA,+C;AACA,wD;AACA,qB;AACA,2B;AACA,yB;AACA,4C;AACA,2D;AACA,qB;AACA,6C;AACA,+C;AACA,8C;AACA,2C;AACA,qB;AACA,wC;AACA,8C;AACA,iC;AACA,qB;AACA,2B;AACA,0B;AACA,4C;AACA,2D;AACA,qB;AACA,4C;AACA,4B;AACA,+C;AACA,wD;AACA,qB;AACA,2B;AACA,yB;AACA,yB;AACA,0B;AACA,8B;AACA,yB;AACA,yB;AACA,4B;AACA,sE;AACA,sE;AACA,0D;AACA,kC;AACA,yB;AACA,qB;AACA,iF;AACA,+B;AACA,qB;AACA,iH;AACA,oC;AACA,wB;AACA,kD;AACA,mD;AACA,qD;AACA,2B;;AAEA,a;AACA,+D;AACA,kE;AACA,kE;AACA,sD;AACA,8B;AACA,qB;AACA,iB;AACA,6E;AACA,2B;AACA,iB;AACA,6G;AACA,gC;AACA,oB;AACA,8C;AACA,+C;AACA,iD;AACA,uB;AACA,a;AACA,S;AACA,8B;AACA,oC;AACA,wC;AACA,iE;AACA,4B;AACA,a;AACA,S;AACA,K;AACA,E;;AAEA,e;AACA,4D;AACA,wC;AACA,0B;AACA,2B;AACA,+C;AACA,8E;AACA,2C;AACA,uB;AACA,4B;AACA,+C;AACA,wD;AACA,+C;AACA,uB;AACA,uB;AACA,kC;AACA,6C;AACA,uB;AACA,yB;AACA,yB;AACA,yB;AACA,+C;AACA,wD;AACA,6C;AACA,uB;AACA,sB;AACA,sB;AACA,sB;AACA,+B;AACA,6C;AACA,uB;AACA,S;AACA,M;;AAEA,4C;AACA,4C;AACA,mB;AACA,S;AACA,wC;AACA,0B;AACA,yB;AACA,8C;AACA,6B;AACA,wB;AACA,2C;AACA,oD;AACA,iB;AACA,uC;AACA,uB;AACA,S;AACA,K;AACA,E;;AAEA,iB;AACA,4D;AACA,wC;AACA,0B;AACA,2B;AACA,uB;AACA,4B;AACA,yB;AACA,sB;AACA,yB;AACA,sB;AACA,yB;AACA,sB;AACA,+B;AACA,+B;AACA,uB;AACA,oB;AACA,mE;AACA,uB;AACA,S;AACA,M;;AAEA,4C;AACA,4C;AACA,mB;AACA,S;AACA,wC;AACA,0B;AACA,2B;AACA,gD;AACA,gD;AACA,4D;AACA,iC;AACA,4B;AACA,+C;AACA,0D;AACA,+D;AACA,iD;AACA,qB;AACA,iB;AACA,uB;AACA,wB;AACA,uB;AACA,4B;AACA,wB;AACA,yB;AACA,sB;AACA,yB;AACA,sB;AACA,yB;AACA,sB;AACA,uB;AACA,yB;AACA,+B;AACA,6B;AACA,uB;AACA,oB;AACA,mD;AACA,uB;AACA,S;AACA,K;AACA,E;;AAEA,qB;AACA,4D;AACA,wC;AACA,0B;AACA,wB;AACA,mE;AACA,uB;AACA,uB;AACA,wD;AACA,4B;AACA,uB;AACA,oB;AACA,gC;AACA,+B;AACA,uB;AACA,S;AACA,M;;AAEA,4C;AACA,4C;AACA,mB;AACA,S;AACA,wC;AACA,0B;AACA,4B;AACA,qD;AACA,gC;AACA,6C;AACA,iB;AACA,uB;AACA,uB;AACA,uB;AACA,oB;AACA,gC;AACA,6B;AACA,uB;AACA,S;AACA,K;AACA,E;;AAEA,mB;AACA,4D;AACA,wC;AACA,0B;AACA,sB;AACA,oD;AACA,wD;AACA,uC;AACA,uB;AACA,sB;AACA,sB;AACA,4B;AACA,6C;AACA,uB;AACA,2B;AACA,uB;AACA,4B;AACA,yB;AACA,yB;AACA,yB;AACA,oG;AACA,wD;AACA,6C;AACA,iD;AACA,iB;AACA,uB;AACA,S;AACA,M;;AAEA,4C;AACA,4C;AACA,mB;AACA,S;AACA,wC;AACA,0B;AACA,yB;AACA,yB;AACA,yB;AACA,8C;AACA,wD;AACA,gC;AACA,6C;AACA,iB;AACA,uB;AACA,yB;AACA,oG;AACA,wD;AACA,6C;AACA,iC;AACA,iB;AACA,uB;AACA,wB;AACA,2B;AACA,uB;AACA,4B;AACA,wB;AACA,sB;AACA,sB;AACA,sB;AACA,uB;AACA,oB;AACA,oD;AACA,uB;AACA,S;AACA,K;AACA,E;;AAEA,a;AACA,4D;AACA,wC;AACA,0B;AACA,sB;AACA,sB;AACA,mD;AACA,mE;AACA,wC;AACA,2C;AACA,uB;AACA,2B;AACA,uB;AACA,4B;AACA,yB;AACA,yB;AACA,yB;AACA,sB;AACA,0B;AACA,6C;AACA,uB;AACA,oB;AACA,oE;AACA,uB;AACA,S;AACA,M;;AAEA,4C;AACA,4C;AACA,mB;AACA,S;AACA,wC;AACA,0B;AACA,sB;AACA,8C;AACA,uD;AACA,gC;AACA,iD;AACA,iB;AACA,uB;AACA,yB;AACA,0B;;AAEA,uF;AACA,wE;AACA,gD;AACA,uB;AACA,yB;AACA,yB;AACA,yB;AACA,8C;AACA,8B;AACA,iC;AACA,iB;AACA,uB;AACA,wB;AACA,2B;AACA,uB;AACA,4B;AACA,wB;AACA,sB;AACA,sB;AACA,uB;AACA,oB;AACA,oD;AACA,uB;AACA,S;AACA,K;AACA,E;;AAEA,c;AACA,4D;AACA,wC;AACA,0B;AACA,2B;AACA,uB;AACA,4B;AACA,yB;AACA,sB;AACA,yB;AACA,sB;AACA,yB;AACA,sB;AACA,mE;AACA,qC;AACA,iD;AACA,iB;AACA,uB;AACA,oB;AACA,mE;AACA,uB;AACA,S;AACA,M;;AAEA,4C;AACA,4C;AACA,mB;AACA,S;AACA,wC;AACA,0B;AACA,sB;AACA,sB;AACA,8C;AACA,gD;AACA,0D;AACA,+B;AACA,qB;AACA,6B;AACA,wB;AACA,2C;AACA,oD;;AAEA,2D;AACA,2C;AACA,iB;AACA,uB;AACA,wB;AACA,2B;AACA,uB;AACA,4B;AACA,wB;AACA,uB;AACA,yB;AACA,yB;AACA,yB;AACA,yB;AACA,sB;AACA,8C;AACA,qC;AACA,iC;AACA,iB;AACA,uB;AACA,oB;AACA,mD;AACA,uB;AACA,S;AACA,K;AACA,E;;AAEA,W;AACA,O;AACA,iG;AACA,oD;AACA,kB;AACA,+D;AACA,Q;AACA,2E;AACA,iF;AACA,4C;AACA,uE;AACA,wD;AACA,Q;AACA,0B;AACA,O;AACA,sB;AACA,O;AACA,qD;AACA,iD;AACA,gG;AACA,kC;AACA,O;AACA,uC;AACA,2C;AACA,0B;AACA,S;AACA,uB;AACA,gC;;AAEA,a;AACA,8B;AACA,6B;AACA,yB;AACA,4B;AACA,e;AACA,qB;AACA,wC;AACA,wB;AACA,a;AACA,S;;AAEA,oD;AACA,M;AACA,O;AACA,sD;AACA,kE;AACA,8C;AACA,O;AACA,8D;AACA,mB;AACA,iC;AACA,S;AACA,+B;AACA,iC;AACA,S;AACA,kD;AACA,gD;AACA,S;AACA,kD;AACA,M;AACA,O;AACA,gC;AACA,8B;AACA,sE;AACA,O;AACA,yD;AACA,mC;AACA,4B;AACA,wC;AACA,S;AACA,K;AACA,E","file":"/packages/vazco_universe-html-purifier.js","sourcesContent":["/*\n * HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Licensed under the Apache License, Version 2.0 or Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n\n * added support of HTML5 by Krzysztof Różalski <cristo.rabani@gmail.com>\n */\n\n// Regular Expressions for parsing tags and attributes (modified attribute name matcher, to catch xml:lang)\nvar startTag = /^<([\\w-]+\\:?\\w*)((?:\\s+[a-zA-Z_:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n\tendTag = /^<\\/([\\w-]+)[^>]*>/,\n\tattr = /([\\w-]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g;\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\tfor ( var i = 0; i < items.length; i++ )\n\t\tobj[ items[i] ] = true;\n\treturn obj;\n}\n\nvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,keygen,link,meta,menuitem,source,track,param,embed,wbr\");\n\nvar block = makeMap(\"article,aside,address,applet,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,form,footer,frameset,hr,iframe,header,hgroup,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,progress,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video\");\n\nvar inline = makeMap(\"a,abbr,acronym,applet,audio,b,basefont,bdo,big,br,button,cite,code,command,del,details,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,mark,meter,nav,object,q,s,samp,script,select,small,span,strike,strong,sub,summary,sup,textarea,tt,u,time,var\");\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\");\n\n// Attributes that have their values filled in disabled=\"disabled\"\nvar fillAttrs = makeMap(\"checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected\");\n\n// Special Elements (can contain anything)\nvar special = makeMap(\"script,style\");\n\nHTMLParser = function( html, handler ) {\n\tvar index, chars, match, stack = [], last = html;\n\tstack.last = function(){\n\t\treturn this[ this.length - 1 ];\n\t};\n\n\tfunction parseStartTag( tag, tagName, rest, unary ) {\n\t\tif ( block[ tagName ] ) {\n\t\t\twhile ( stack.last() && inline[ stack.last() ] ) {\n\t\t\t\tparseEndTag( \"\", stack.last() );\n\t\t\t}\n\t\t}\n\n\t\tif ( closeSelf[ tagName ] && stack.last() === tagName ) {\n\t\t\tparseEndTag( \"\", tagName );\n\t\t}\n\n\t\tunary = empty[ tagName ] || !!unary;\n\n\t\tif ( !unary )\n\t\t\tstack.push( tagName );\n\n\t\tif ( handler.start ) {\n\t\t\tvar attrs = [];\n\n\t\t\trest.replace(attr, function(match, name) {\n\t\t\t\tvar value = arguments[2] ? arguments[2] :\n\t\t\t\t\targuments[3] ? arguments[3] :\n\t\t\t\t\targuments[4] ? arguments[4] :\n\t\t\t\t\tfillAttrs[name] ? name : \"\";\n\n\t\t\t\tattrs.push({\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tescaped: value.replace(/(^|[^\\\\])\"/g, '$1\\\\\\\"') //\"\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif ( handler.start )\n\t\t\t\thandler.start( tagName, attrs, unary );\n\t\t}\n\t}\n\n\tfunction parseEndTag( tag, tagName ) {\n\t\tvar pos;\n\n\t\t// If no tag name is provided, clean shop\n\t\tif (!tagName) {\n\t\t\tpos = 0;\n\t\t}\n\n\t\t// Find the closest opened tag of the same type\n\t\telse\n\t\t\tfor ( pos = stack.length - 1; pos >= 0; pos-- )\n\t\t\t\tif ( stack[ pos ] === tagName )\n\t\t\t\t\tbreak;\n\n\t\tif ( pos >= 0 ) {\n\t\t\t// Close all the open elements, up the stack\n\t\t\tfor ( var i = stack.length - 1; i >= pos; i-- )\n\t\t\t\tif ( handler.end )\n\t\t\t\t\thandler.end( stack[ i ] );\n\n\t\t\t// Remove the open elements from the stack\n\t\t\tstack.length = pos;\n\t\t}\n\t}\n\n\twhile ( html ) {\n\t\tchars = true;\n\t\t// Make sure we're not in a script or style element\n\t\tif ( !stack.last() || !special[ stack.last() ] ) {\n\n\t\t\t// Comment\n\t\t\tif ( html.indexOf(\"<!--\") === 0 ) {\n\t\t\t\tindex = html.indexOf(\"-->\");\n\n\t\t\t\tif ( index >= 0 ) {\n\t\t\t\t\tif ( handler.comment )\n\t\t\t\t\t\thandler.comment( html.substring( 4, index ) );\n\t\t\t\t\thtml = html.substring( index + 3 );\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t// end tag\n\t\t\t} else if ( html.indexOf(\"</\") === 0 ) {\n\t\t\t\tmatch = html.match( endTag );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\thtml = html.substring( match[0].length );\n\t\t\t\t\tmatch[0].replace( endTag, parseEndTag );\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t// start tag\n\t\t\t} else if ( html.indexOf(\"<\") === 0 ) {\n\t\t\t\tmatch = html.match( startTag );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\thtml = html.substring( match[0].length );\n\t\t\t\t\tmatch[0].replace( startTag, parseStartTag );\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( chars ) {\n\t\t\t\tindex = html.indexOf(\"<\");\n\n\t\t\t\tvar text = index < 0 ? html : html.substring( 0, index );\n\t\t\t\thtml = index < 0 ? \"\" : html.substring( index );\n\n\t\t\t\tif ( handler.chars )\n\t\t\t\t\thandler.chars( text );\n\t\t\t}\n\n\t\t} else {\n\t\t\thtml = html.replace(new RegExp(\"(.*)<\\/\" + stack.last() + \"[^>]*>\"), function(all, text){\n\t\t\t\ttext = text.replace(/<!--(.*?)-->/g, \"$1\")\n\t\t\t\t\t.replace(/<!\\[CDATA\\[(.*?)]]>/g, \"$1\");\n\n\t\t\t\tif ( handler.chars )\n\t\t\t\t\thandler.chars( text );\n\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\tparseEndTag( \"\", stack.last() );\n\t\t}\n\n\t\tif ( html === last )\n\t\t\tthrow \"Parse Error: \" + html;\n\t\tlast = html;\n\t}\n\n\t// Clean up any remaining tags\n\tparseEndTag();\n};","var allowHeaders = true;\nvar stack = [];\nvar active_elements = [];\nvar customTags = {};\nvar root;\nvar insertion_mode;\nvar noFormatting;\nvar preferB_I = false;\nvar preferStrong_Em = false;\nvar withoutTags;\n\n\nvar scope_markers = {'td': true, 'th': true, 'caption': true};\nvar tags_with_implied_end = {'li': true, 'p': true};\nvar allowed_attributes = {\n    all_elements: ['class', 'style', 'id'],\n    a: ['href', 'target', 'title', 'name', 'rel', 'rev', 'type'],\n    blockquote: ['cite'],\n    img: ['src', 'alt', 'title', 'longdesc'],\n    td: ['colspan'],\n    th: ['colspan'],\n    tr: ['rowspan'],\n    table: ['border']\n};\nvar allowed_attributes_as_hash;\nvar selfClosing = {\n    br: true,\n    hr: true,\n    img: true\n};\nvar dontIndent = {\n    strong: true,\n    b: true,\n    i: true,\n    em: true,\n    pre: true\n};\nvar indent = false;\nvar indent_string = \"    \";\nvar indentation = function (depth, switchOff) {\n    if (noFormatting) return \"\";\n    if (!indent) return \"\";\n    if (switchOff) indent = false;\n    var result = \"\\n\";\n    for (var i = 0; i < depth; i++) {\n        result += indent_string;\n    }\n    return result;\n};\n\nvar TextNode = function (text) {\n    this.text = text.replace(/\\s+/g, ' ');\n};\n\nTextNode.prototype = {\n    isEmpty: function () {\n        return !this.text;\n    },\n    textContent: function () {\n        return this.text;\n    },\n    toString: function () {\n        return this.isEmpty() ? '' : indentation(this.depth(), true) + this.text.replace(/(&nbsp;)+/, ' ');\n    },\n    depth: function () {\n        return this.parent.depth() + 1;\n    }\n};\n\nvar Node = function (name) {\n    this.name = name;\n    this.children = [];\n    this.attributes = {};\n};\n\nNode.prototype = {\n    appendChild: function (child) {\n        this.children.push(child);\n        child.parent = this;\n        return child;\n    },\n    removeChild: function (child) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            if (this.children[i] === child) {\n                return this.children.splice(i, i);\n            }\n        }\n        return null;\n    },\n    lastChild: function () {\n        return this.children[this.children.length - 1];\n    },\n    clone: function () {\n        var clone = new Node(this.name);\n        for (var i in this.attributes) {\n            clone.attributes[i] = this.attributes[i];\n        }\n        return clone;\n    },\n    startTag: function () {\n        return \"<\" + this.name + this.attributeString() + \">\";\n    },\n    endTag: function () {\n        return \"</\" + this.name + \">\";\n    },\n    selfClosingTag: function () {\n        return \"<\" + this.name + this.attributeString() + \"/>\";\n    },\n    attributeString: function () {\n        var string = \"\";\n\n        var allowed_for_tag = allowed_attributes_as_hash[this.name] || {};\n        var allowed_for_all = allowed_attributes_as_hash['all_elements'] || {};\n\n        for (var i = 0, len = (this.attributes || []).length; i < len; i++) {\n            var name = this.attributes[i].name;\n            var value = this.attributes[i].value;\n            if ((allowed_for_tag[name] || allowed_for_all[name]) && value) {\n                if (name === 'href') {\n                    // don't allow links to anywhere other than http(s)\n                    // because they could contain JavaScript (javascript:) or other bad things!\n                    var permittedRegex = /^https?:\\/\\//i;\n                    if (!permittedRegex.test(value)) {\n                        // if not allowed, set the attribute to be empty\n                        value = '';\n                    }\n                }\n\n                string += \" \" + name + \"=\\\"\" + value + \"\\\"\";\n            }\n        }\n        return string;\n    },\n    innerHTML: function () {\n        var string = \"\";\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            string += this.children[i];\n        }\n        return string;\n    },\n    textContent: function () {\n        var text = \"\";\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            if (this.children[i] instanceof TextNode) {\n                text += this.children[i].text;\n            }\n        }\n        return text;\n    },\n    toString: function () {\n        if (this.isEmpty()) return '';\n\n        var string = \"\";\n        if (selfClosing[this.name]) {\n            string = indentation(this.depth(), true) + this.selfClosingTag();\n        } else {\n            indent = dontIndent[this.name] ? indent : true;\n            string = indentation(this.depth(), dontIndent[this.name]) + this.startTag() + this.innerHTML();\n            indent = dontIndent[this.name] ? indent : true;\n            string += indentation(this.depth()) + this.endTag();\n        }\n        return string;\n    },\n    depth: function () {\n        return this.parent ? this.parent.depth() + 1 : -1;\n    },\n    isEmpty: function () {\n        // Zaption mod: self-closing elements never count as empty\n        // otherwise <p><br/></p> gets removed entirely\n        if (selfClosing[this.name]) {\n            return false;\n        }\n\n        if (typeof(this._isEmpty) === \"undefined\") {\n            this._isEmpty = true;\n            for (var i = 0, len = this.children.length; i < len; i++) {\n                if (!this.children[i].isEmpty()) {\n                    this._isEmpty = false;\n                    break;\n                }\n            }\n        }\n        return this._isEmpty;\n    }\n};\n\nfunction init(settings) {\n    root = new Node('html');\n    stack = [root];\n    active_elements = [];\n    allowed_attributes_as_hash = {};\n    var attr, i;\n    for (var key in allowed_attributes) {\n        allowed_attributes_as_hash[key] = {};\n        for (i in allowed_attributes['all_elements']) {\n            attr = allowed_attributes['all_elements'][i];\n            allowed_attributes_as_hash[key][attr] = true;\n        }\n        if (key === 'all_elements') {\n            continue;\n        }\n        for (i in allowed_attributes[key]) {\n            attr = allowed_attributes[key][i];\n            allowed_attributes_as_hash[key][attr] = true;\n        }\n    }\n\n    noFormatting = !!settings.noFormatting;\n    preferStrong_Em = !!settings.preferStrong_Em;\n    preferB_I = !preferStrong_Em && !!settings.preferB_I;\n    allowHeaders = !settings.noHeaders;\n    withoutTags = {};\n\n    if(typeof settings.withoutTags === 'string' && settings.withoutTags){\n        settings.withoutTags = [settings.withoutTags];\n    }\n\n    if(settings.withoutTags && settings.withoutTags.length){\n        for (var i = settings.withoutTags.length -1 ; i >= 0; i--) {\n            withoutTags[settings.withoutTags[i]] = true;\n        }\n    }\n}\n\nfunction last_el(list) {\n    var len = list.length;\n    if (len === 0) {\n        return null;\n    }\n    return list[len - 1];\n}\n\nfunction in_array(arr, elem) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === elem) return true;\n    }\n    return false;\n}\n\nfunction current_node() {\n    return last_el(stack);\n}\n\nfunction reconstruct_the_active_formatting_elements() {\n    if (active_elements.length === 0 || in_array(stack, last_el(active_elements))) {\n        return;\n    }\n    var entry;\n    for (var i = active_elements.length; i > 0; i--) {\n        entry = active_elements[i - 1];\n        if (in_array(stack, entry)) {\n            break;\n        }\n    }\n    do {\n        var clone = entry.clone();\n        current_node().appendChild(clone);\n        stack.push(clone);\n        active_elements[i] = clone;\n        i += 1;\n    } while (i !== active_elements.length);\n}\n\nfunction has_element_with(arr_of_elements, tagName) {\n    for (var i = arr_of_elements.length; i > 0; i--) {\n        if (arr_of_elements[i - 1].name === tagName) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction in_scope(tagName) {\n    return has_element_with(stack, tagName);\n}\n\nfunction in_table_scope(tagName) {\n    for (var i = stack.length; i > 0; i--) {\n        var nodeTag = stack[i - 1].name;\n        if (nodeTag === tagName) {\n            return true;\n        } else if (nodeTag === 'table' || nodeTag === 'html') {\n            return false;\n        }\n    }\n    return false;\n}\n\nfunction insert_html_element_for(tagName, attrs) {\n    var node = new Node(tagName);\n    node.attributes = attrs;\n    current_node().appendChild(node);\n    stack.push(node);\n    return node;\n}\n\nfunction generate_implied_end_tags(exception) {\n    var tagName = current_node().name;\n    while (tags_with_implied_end[tagName] && tagName !== exception) {\n        end(tagName);\n        tagName = current_node().name;\n    }\n}\n\nfunction trim_to_1_space(str) {\n    return str.replace(/^\\s+/, ' ').replace(/\\s+$/, ' ');\n}\n\nfunction clear_stack_to_table_context() {\n    clear_stack_to_context_by_tags(['table', 'html']);\n}\n\nfunction clear_stack_to_table_body_context() {\n    clear_stack_to_context_by_tags(['tbody', 'tfoot', 'thead', 'html']);\n}\n\nfunction clear_stack_to_table_row_context() {\n    clear_stack_to_context_by_tags(['tr', 'html']);\n}\n\nfunction clear_stack_to_context_by_tags(tags) {\n    while (!in_array(tags, current_node().name)) {\n        stack.pop();\n    }\n}\n\nfunction clear_active_elements_to_last_marker() {\n    var entry;\n    do {\n        entry = active_elements.pop();\n    } while (!scope_markers[entry.name]);\n}\n\nfunction reset_insertion_mode() {\n    var last = false;\n    var node;\n    for (var i = stack.length - 1; i >= 0; i--) {\n        node = stack[i];\n        if (node === stack[0]) {\n            last = true;\n        }\n        switch (node.name) {\n            case 'th':\n            case 'td':\n                if (!last) {\n                    insertion_mode = InCell;\n                    return;\n                }\n            case 'tr':\n                insertion_mode = InRow;\n                return;\n            case 'tbody':\n            case 'thead':\n            case 'tfoot':\n                insertion_mode = InTableBody;\n                return;\n            case 'caption':\n                insertion_mode = InCaption;\n                return;\n            case 'colgroup':\n                insertion_mode = InColumnGroup;\n                return;\n            case 'table':\n                insertion_mode = InTable;\n                return;\n            default:\n                if (last) {\n                    insertion_mode = InBody;\n                    return;\n                }\n        }\n    }\n}\n\nfunction close_the_cell() {\n    if (in_table_scope('td')) {\n        end('td');\n    } else {\n        end('th');\n    }\n}\n\nfunction start(tagName, attrs, unary) {\n    insertion_mode.insertion_mode_start(tagName, attrs, unary);\n}\n\nfunction end(tagName) {\n    insertion_mode.insertion_mode_end(tagName);\n}\n\nfunction chars(text) {\n    if (typeof(text) === 'undefined') {\n        return;\n    }\n    text = text.replace(/\\n\\s*\\n\\s*\\n*/g, '\\n\\n').replace(/(^\\n\\n|\\n\\n$)/g, '');\n    var paragraphs = text.split('\\n\\n');\n    var trimmedText;\n    if (paragraphs.length > 1) {\n        for (var i in paragraphs) {\n            start('p');\n            reconstruct_the_active_formatting_elements();\n            trimmedText = trim_to_1_space(paragraphs[i]);\n            current_node().appendChild(new TextNode(trimmedText));\n            end('p');\n        }\n    } else {\n        if (text.match(/^\\s*$/g) && current_node().children.length && current_node().lastChild().name === 'br') {\n            return;\n        }\n        reconstruct_the_active_formatting_elements();\n        trimmedText = trim_to_1_space(paragraphs[0]);\n        current_node().appendChild(new TextNode(trimmedText));\n    }\n}\n\nvar InBody = {\n    insertion_mode_start: function (tagName, attrs) {\n        var node;\n        tagName = tagName.toLowerCase();\n        if (withoutTags[tagName]) {\n            return;\n        }\n        if (preferStrong_Em) {\n            switch (tagName) {\n                case 'b':\n                    start('strong');\n                    return;\n                case 'i':\n                    start('em');\n                    return;\n            }\n        } else if (preferB_I) {\n            switch (tagName) {\n                case 'strong':\n                    start('b');\n                    return;\n                case 'em':\n                    start('i');\n                    return;\n            }\n        }\n        switch (tagName) {\n            case 'h1':\n            case 'h2':\n            case 'h3':\n            case 'h4':\n            case 'h5':\n            case 'h6':\n            case 'h7':\n                if (!allowHeaders) {\n                    start('p');\n                    if (preferB_I) {\n                        start('b');\n                    } else {\n                        start('strong');\n                    }\n                    return;\n                }\n            case 'blockquote':\n            case 'ol':\n            case 'p':\n            case 'ul':\n            case 'pre': // Techically PRE shouldn't be in this groups, since newlines should be ignored after a pre tag\n                if (in_scope('p')) {\n                    end('p');\n                }\n                insert_html_element_for(tagName, attrs);\n                return;\n            case 'li':\n                if (in_scope('p')) {\n                    end('p');\n                }\n                node = current_node();\n                while (node.name === 'li') {\n                    stack.pop();\n                }\n                insert_html_element_for(tagName, attrs);\n                return;\n            case 'a':\n                for (var i = active_elements.length; i > 0; i--) {\n                    if (active_elements[i - 1].name === 'a') {\n                        end('a');\n                        active_elements.splice(i - 1, 1);\n                    }\n                }\n                reconstruct_the_active_formatting_elements();\n                node = insert_html_element_for(tagName, attrs);\n                active_elements.push(node);\n                return;\n            case 'strong':\n            case 'b':\n            case 'em':\n            case 'i':\n            case 'u':\n            case 'span':\n                reconstruct_the_active_formatting_elements();\n                node = insert_html_element_for(tagName, attrs);\n                active_elements.push(node);\n                return;\n            case 'table':\n                if (in_scope('p')) {\n                    end('p');\n                }\n                insert_html_element_for(tagName, attrs);\n                insertion_mode = InTable;\n                return;\n            case 'br':\n            case 'img':\n                reconstruct_the_active_formatting_elements();\n                insert_html_element_for(tagName, attrs);\n                stack.pop();\n                return;\n        }\n        if (customTags[tagName]) {\n            if (selfClosing[tagName]) {\n                reconstruct_the_active_formatting_elements();\n                insert_html_element_for(tagName, attrs);\n                stack.pop();\n                return;\n            } else {\n                reconstruct_the_active_formatting_elements();\n                node = insert_html_element_for(tagName, attrs);\n                active_elements.push(node);\n                return;\n            }\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof tagName === 'undefined') {\n            return;\n        }\n        var node;\n        tagName = tagName.toLowerCase();\n        if (!withoutTags[tagName]) {\n            if (preferStrong_Em) {\n                switch (tagName) {\n                    case 'b':\n                        end('strong');\n                        return;\n                    case 'i':\n                        end('em');\n                        return;\n                }\n            } else if (preferB_I) {\n                switch (tagName) {\n                    case 'strong':\n                        end('b');\n                        return;\n                    case 'em':\n                        end('i');\n                        return;\n                }\n            }\n            switch (tagName) {\n                case 'h1':\n                case 'h2':\n                case 'h3':\n                case 'h4':\n                case 'h5':\n                case 'h6':\n                case 'h7':\n                    if (!allowHeaders) {\n                        if (preferB_I) {\n                            end('b');\n                        } else {\n                            end('strong');\n                        }\n                        end('p');\n                        return;\n                    }\n                    if (in_scope(tagName)) {\n                        generate_implied_end_tags();\n                        do {\n                            node = stack.pop();\n                        } while (node.name !== tagName);\n                    }\n                    return;\n                case 'blockquote':\n                case 'ol':\n                case 'ul':\n                case 'pre': // Techically PRE shouldn't be in this groups, since newlines should be ignored after a pre tag\n                    if (in_scope(tagName)) {\n                        generate_implied_end_tags();\n                    }\n                    if (in_scope(tagName)) {\n                        do {\n                            node = stack.pop();\n                        } while (node.name !== tagName);\n                    }\n                    return;\n                case 'p':\n                    if (in_scope(tagName)) {\n                        generate_implied_end_tags(tagName);\n                    }\n                    var no_p_in_scope = true;\n                    while (in_scope(tagName)) {\n                        no_p_in_scope = false;\n                        node = stack.pop();\n                    }\n                    if (no_p_in_scope) {\n                        start('p', [], false);\n                        end('p');\n                    }\n                    return;\n                case 'li':\n                    if (in_scope(tagName)) {\n                        generate_implied_end_tags(tagName);\n                    }\n                    if (in_scope(tagName)) {\n                        do {\n                            node = stack.pop();\n                        } while (node.name !== tagName);\n                    }\n                    return;\n                case 'a':\n                case 'i':\n                case 'em':\n                case 'strong':\n                case 'b':\n                case 'u':\n                case 'span':\n                    for (var i = active_elements.length; i > 0; i--) {\n                        if (active_elements[i - 1].name === tagName) {\n                            node = active_elements[i - 1];\n                            break;\n                        }\n                    }\n                    if (typeof(node) === 'undefined' || !in_array(stack, node)) {\n                        return;\n                    }\n                    // Step 2 from the algorithm in the HTML5 spec will never be necessary with the tags we allow\n                    var popped_node;\n                    do {\n                        popped_node = stack.pop();\n                    } while (popped_node !== node);\n                    active_elements.splice(i - 1, 1);\n                    return;\n\n            }\n            if (customTags[tagName] && !selfClosing[tagName]) {\n                for (var i = active_elements.length; i > 0; i--) {\n                    if (active_elements[i - 1].name === tagName) {\n                        node = active_elements[i - 1];\n                        break;\n                    }\n                }\n                if (typeof(node) === 'undefined' || !in_array(stack, node)) {\n                    return;\n                }\n                // Step 2 from the algorithm in the HTML5 spec will never be necessary with the tags we allow\n                var popped_node;\n                do {\n                    popped_node = stack.pop();\n                } while (popped_node !== node);\n                active_elements.splice(i - 1, 1);\n                return;\n            }\n        }\n        node = current_node();\n        if (node.name === tagName) {\n            generate_implied_end_tags();\n            while (stack.length > 0 && node !== current_node()) {\n                stack.pop();\n            }\n        }\n    }\n};\n\nvar InTable = {\n    insertion_mode_start: function (tagName, attrs, unary) {\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'caption':\n                clear_stack_to_table_context();\n                active_elements.push(insert_html_element_for(tagName, attrs));\n                insertion_mode = InCaption;\n                return;\n            case 'colgroup':\n                clear_stack_to_table_context();\n                insert_html_element_for(tagName, attrs);\n                insertion_mode = InColumnGroup;\n                return;\n            case 'col':\n                start('colgroup');\n                start(tagName, attrs, unary);\n                return;\n            case 'tbody':\n            case 'tfoot':\n            case 'thead':\n                clear_stack_to_table_context();\n                insert_html_element_for(tagName, attrs);\n                insertion_mode = InTableBody;\n                return;\n            case 'td':\n            case 'th':\n            case 'tr':\n                start('tbody');\n                start(tagName, attrs, unary);\n                return;\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof(tagName) === undefined) {\n            return;\n        }\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'table':\n                if (in_table_scope('table')) {\n                    var node;\n                    do {\n                        node = stack.pop();\n                    } while (node.name !== 'table');\n                }\n                reset_insertion_mode();\n                return;\n        }\n    }\n};\n\nvar InCaption = {\n    insertion_mode_start: function (tagName, attrs, unary) {\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'caption':\n            case 'col':\n            case 'colgroup':\n            case 'tbody':\n            case 'td':\n            case 'tfoot':\n            case 'th':\n            case 'thead':\n            case 'tr':\n                end('caption');\n                start(tagName);\n                return;\n            default:\n                InBody.insertion_mode_start(tagName, attrs, unary);\n                return;\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof(tagName) === undefined) {\n            return;\n        }\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'caption':\n                if (in_table_scope('caption')) {\n                    generate_implied_end_tags();\n                    if (current_node().name === 'caption') {\n                        var node;\n                        do {\n                            node = stack.pop();\n                        } while (node.name !== 'caption');\n                        clear_active_elements_to_last_marker();\n                        insertion_mode = InTable;\n                    }\n                }\n                return;\n            case \"body\":\n            case \"col\":\n            case \"colgroup\":\n            case \"html\":\n            case \"tbody\":\n            case \"td\":\n            case \"tfoot\":\n            case \"th\":\n            case \"thead\":\n            case \"tr\":\n                return;\n            case 'table':\n                end('caption');\n                end('table');\n                return;\n            default:\n                InBody.insertion_mode_end(tagName);\n                return;\n        }\n    }\n};\n\nvar InColumnGroup = {\n    insertion_mode_start: function (tagName, attrs, unary) {\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'html':\n                InBody.insertion_mode_start(tagName, attrs, unary);\n                return;\n            case 'col':\n                insert_html_element_for(tagName, attrs);\n                stack.pop();\n                return;\n            default:\n                end('colgroup');\n                start(tagName);\n                return;\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof(tagName) === undefined) {\n            return;\n        }\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'colgroup':\n                if (current_node().name !== 'html') {\n                    stack.pop();\n                    insertion_mode = InTable;\n                }\n                return;\n            case 'col':\n                return;\n            default:\n                end('colgroup');\n                end(tagName);\n                return;\n        }\n    }\n};\n\nvar InTableBody = {\n    insertion_mode_start: function (tagName, attrs, unary) {\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'tr':\n                clear_stack_to_table_body_context();\n                insert_html_element_for(tagName, attrs);\n                insertion_mode = InRow;\n                return;\n            case 'th':\n            case 'td':\n                start('tr');\n                start(tagName, attrs, unary);\n                return;\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"tbody\":\n            case \"tfoot\":\n            case \"thead\":\n                if (in_table_scope('tbody') || in_table_scope('thead') || in_table_scope('tfoot')) {\n                    clear_stack_to_table_body_context();\n                    end(current_node().name);\n                    start(tagName, attrs, unary);\n                }\n                return;\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof(tagName) === undefined) {\n            return;\n        }\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'tbody':\n            case 'tfoot':\n            case 'thead':\n                if (in_table_scope(tagName)) {\n                    clear_stack_to_table_body_context();\n                    stack.pop();\n                    insertion_mode = InTable;\n                }\n                return;\n            case 'table':\n                if (in_table_scope('tbody') || in_table_scope('thead') || in_table_scope('tfoot')) {\n                    clear_stack_to_table_body_context();\n                    end(current_node().name);\n                    end(tagName);\n                }\n                return;\n            case \"body\":\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"html\":\n            case \"td\":\n            case \"th\":\n            case \"tr\":\n                return;\n            default:\n                InTable.insertion_mode_end(tagName);\n                return;\n        }\n    }\n};\n\nvar InRow = {\n    insertion_mode_start: function (tagName, attrs, unary) {\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'th':\n            case 'td':\n                clear_stack_to_table_row_context();\n                var node = insert_html_element_for(tagName, attrs);\n                insertion_mode = InCell;\n                active_elements.push(node);\n                return;\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"tbody\":\n            case \"tfoot\":\n            case \"thead\":\n            case \"tr\":\n                end('tr');\n                start(tagName, attrs, unary);\n                return;\n            default:\n                InTable.insertion_mode_start(tagName, attrs, unary);\n                return;\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof(tagName) === undefined) {\n            return;\n        }\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case 'tr':\n                if (in_table_scope(tagName)) {\n                    clear_stack_to_table_row_context();\n                    stack.pop();\n                    insertion_mode = InTableBody;\n                }\n                return;\n            case 'table':\n                end('tr');\n\n                // this line was in the original source but attrs/unary are not defined\n                // so not sure what to do with it. how was this working?\n                // start(tagName, attrs, unary);\n                return;\n            case \"tbody\":\n            case \"tfoot\":\n            case \"thead\":\n                if (in_table_scope(tagName)) {\n                    end('tr');\n                    end(tagName);\n                }\n                return;\n            case \"body\":\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"html\":\n            case \"td\":\n            case \"th\":\n                return;\n            default:\n                InTable.insertion_mode_end(tagName);\n                return;\n        }\n    }\n};\n\nvar InCell = {\n    insertion_mode_start: function (tagName, attrs, unary) {\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"tbody\":\n            case \"td\":\n            case \"tfoot\":\n            case \"th\":\n            case \"thead\":\n            case \"tr\":\n                if (in_table_scope('td') || in_table_scope('th')) {\n                    close_the_cell();\n                    start(tagName, attrs, unary);\n                }\n                return;\n            default:\n                InBody.insertion_mode_start(tagName, attrs, unary);\n                return;\n        }\n    },\n\n    insertion_mode_end: function (tagName) {\n        if (typeof(tagName) === undefined) {\n            return;\n        }\n        tagName = tagName.toLowerCase();\n        switch (tagName) {\n            case \"td\":\n            case \"th\":\n                if (in_table_scope(tagName)) {\n                    generate_implied_end_tags();\n                    if (current_node().name !== tagName) {\n                        return;\n                    }\n                    var node;\n                    do {\n                        node = stack.pop();\n                    } while (node.name !== tagName);\n\n                    clear_active_elements_to_last_marker();\n                    insertion_mode = InRow;\n                }\n                return;\n            case \"body\":\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"html\":\n                return;\n            case \"table\":\n            case \"tbody\":\n            case \"tfoot\":\n            case \"thead\":\n            case \"tr\":\n                if (in_table_scope(tagName)) {\n                    close_the_cell();\n                    end(tagName);\n                }\n                return;\n            default:\n                InBody.insertion_mode_end(tagName);\n                return;\n        }\n    }\n};\n\nUniHTML = {\n    /**\n     * Parse html string and calls callback in the same order as tags in html string are present.\n     * Method supports html5, including custom tags.\n     * @param html\n     * @param handler {Object} object of callbacks for example:\n     * {\n     *          // attributesOnTag is an Object like {name, value, escaped}\n     *      start: function(tagName, attributesOnTag, isSelfClosing), // open tag\n     *      end: function(tagName), // close\n     *      chars: function(text), // text between open and closing tag\n     *      comment: function(text) // text from comment\n     * }\n     * @throws Parse Error\n     */\n    parse: HTMLParser,\n    /**\n     * Cleanup dirty html from unknown/untrusted tags\n     * @param html {string} html string to purify\n     * @param settings {Object} noFormatting, preferStrong_Em, preferB_I, noHeaders, withoutTags\n     * @returns {HTML|string|void}\n     */\n    purify: function (html, settings) {\n        if (typeof settings !== 'object') {\n            settings = {};\n        }\n        init(settings);\n        insertion_mode = InBody;\n\n        try {\n            HTMLParser(html, {\n                start: start,\n                end: end,\n                chars: chars\n            });\n        } catch (e) {\n            if (!settings.catchErrors) {\n                throw e;\n            }\n        }\n\n        return root.innerHTML().replace(/^\\s+/, '');\n    },\n    /**\n     * Sets new allowed attributes for one or all tags\n     * @param attributesArray {Array} Array of names of attributes\n     * @param tag {string=} [tag=all_elements]\n     */\n    setNewAllowedAttributes: function (attributesArray, tag) {\n        if (!tag) {\n            tag = 'all_elements';\n        }\n        if (!attributesArray) {\n            attributesArray = [];\n        }\n        if (typeof attributesArray === 'string') {\n            attributesArray = [attributesArray];\n        }\n        allowed_attributes[tag] = attributesArray;\n    },\n    /**\n     * Adds new allowed html tag\n     * @param tagName {string}\n     * @param isSelfClosing {boolean=} a void tags like: img, hr, area\n     */\n    addNewAllowedTag: function (tagName, isSelfClosing) {\n        customTags[tagName] = true;\n        if (isSelfClosing) {\n            selfClosing[tagName] = true;\n        }\n    }\n};"]}